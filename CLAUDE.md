# AdCP Sales Agent Server - Claude Agent Notes

## Project Overview

This is a Python-based reference implementation of the Advertising Context Protocol (AdCP) V2.3 sales agent. It demonstrates how publishers expose advertising inventory to AI-driven clients through a standardized MCP (Model Context Protocol) interface.

**Primary Deployment Method**: Docker Compose with PostgreSQL, MCP Server, and Admin UI

The server provides:
- **MCP Server**: FastMCP-based server exposing tools for AI agents (port 8080)
- **Admin UI**: Secure web interface with Google OAuth authentication (port 8001)
- **Multi-Tenant Architecture**: Database-backed tenant isolation with subdomain routing
- **Advanced Targeting**: Comprehensive targeting system with overlay and managed-only dimensions
- **Creative Management**: Auto-approval workflows, creative groups, and admin review
- **Human-in-the-Loop**: Optional manual approval mode for sensitive operations
- **Security & Compliance**: Audit logging, principal-based auth, adapter security boundaries
- **Slack Integration**: Per-tenant webhook configuration (no env vars needed)
- **Production Ready**: PostgreSQL database, Docker deployment, health monitoring

## Key Architecture Decisions

### 1. Database-Backed Multi-Tenancy
- **Tenant Isolation**: Each publisher is a tenant with isolated data
- **Principal System**: Within each tenant, principals (advertisers) have unique tokens
- **Subdomain Routing**: Optional routing like `sports.localhost:8080`
- **Configuration**: Per-tenant adapter config, features, and limits
- **Database Support**: SQLite (dev) and PostgreSQL (production)

### 2. Adapter Pattern for Ad Servers
- Base `AdServerAdapter` class defines the interface
- Implementations for GAM, Kevel, Triton, and Mock
- Each adapter handles its own API call logging in dry-run mode
- Principal object encapsulates identity and adapter mappings
- Adapters can provide custom configuration UIs via Flask routes
- Adapter-specific validation and field definitions

### 3. FastMCP Integration
- Uses FastMCP for the server framework
- HTTP transport with header-based authentication (`x-adcp-auth`)
- Context parameter provides access to HTTP request headers
- Tools are exposed as MCP methods

## Core Components

### `main.py` - Server Implementation
- FastMCP server exposing AdCP tools
- Authentication via `x-adcp-auth` header
- Principal resolution and adapter instantiation
- In-memory state management for media buys

### `schemas.py` - Data Models
- Pydantic models for all API contracts
- `Principal` model with `get_adapter_id()` method
- Request/Response models for all operations
- Adapter-specific response models

### `adapters/` - Ad Server Integrations
- `base.py`: Abstract base class defining the interface
- `mock_ad_server.py`: Mock implementation with realistic simulation
- `google_ad_manager.py`: GAM integration with detailed API logging
- Each adapter accepts a `Principal` object for cleaner architecture

### `simulation_full.py` - Full Lifecycle Test
- 7-phase campaign simulation (discovery → completion)
- Realistic timeline with proper date progression
- Performance tracking and optimization
- Demonstrates all API capabilities

## Conductor Workspace Guidelines

### IMPORTANT: Understanding Conductor Workspaces

Conductor workspaces use **git worktrees**, which means:
- Each workspace is a checkout of the main repository at a different branch
- Changes made in a workspace affect the main repository when merged
- **DO NOT DELETE** core files like Alembic migrations, entrypoint.sh, etc.
- The workspace is NOT a separate copy - it's the actual repository

### Working in Conductor Workspaces

When working in a Conductor workspace (e.g., `.conductor/quito/`):

1. **Configuration Changes Only**: 
   - Modify `.env` files for environment-specific settings
   - Create `docker-compose.override.yml` for development features
   - NEVER modify core application files unless that's the intended change

2. **Environment Variables**:
   - All configuration should use environment variables
   - The `.env` file is generated by `setup_conductor_workspace.sh`
   - OAuth credentials come from environment variables, not mounted files

3. **Development Features**:
   - Hot reloading is enabled via `docker-compose.override.yml`
   - Volume mounts preserve the container's `.venv` directory
   - Flask debug mode is enabled for the admin UI

4. **Testing Changes**:
   - Always verify migrations run correctly
   - Test with `docker compose up` in the workspace
   - Ensure no version-controlled files are modified unintentionally

## Recent Major Changes

### AdCP v2.4 Protocol Updates (Latest)
- **Renamed Endpoints**: `list_products` renamed to `get_products` to align with signals agent spec
- **Signal Discovery**: Added optional `get_signals` endpoint for discovering available signals (audiences, contextual, geographic, etc.)
- **Enhanced Targeting**: Added `signals` field to targeting overlay for direct signal activation
- **Terminology Updates**: Renamed `provided_signals` to `aee_signals` for improved clarity
- **Unified Signal Interface**: Signals can now include audiences, contextual data, and geographic information

### AI-Powered Product Management
- **Default Products**: 6 standard products automatically created for new tenants
- **Industry Templates**: Specialized products for news, sports, entertainment, ecommerce
- **AI Configuration**: Uses Gemini 2.5 Flash to analyze descriptions and suggest configs
- **Bulk Operations**: CSV/JSON upload, template browser, quick-create API
- **Product Suggestions API**: REST endpoints for programmatic product discovery
- **Smart Matching**: AI analyzes ad server inventory to recommend optimal placements

### Database Migrations Support 
- **Alembic Integration**: Added Alembic for database schema version control
- **Automatic Migrations**: Migrations run automatically on server startup
- **Multi-Database Support**: Works with both SQLite and PostgreSQL
- **Migration Commands**: `uv run python migrate.py` for running migrations
- **Docker Integration**: `entrypoint.sh` runs migrations before starting server
- **Documentation**: See `docs/database-migrations.md` for detailed guide

### Product Management & Adapter Configuration Improvements
- **Clean Separation of Concerns**: 
  - Basic product fields (name, pricing, countries) in main product form
  - Adapter-specific configuration moved to dedicated UIs
  - Countries field moved to products table (buyer-facing concern)
  - `implementation_config` now exclusively for adapter technical settings
- **Mock Adapter Configuration UI**:
  - Traffic simulation controls (impressions, fill rate, CTR, viewability)
  - Performance simulation (latency, error rates)
  - Test scenarios (normal, high demand, degraded, outage)
  - Debug settings for development
- **UI/UX Improvements**:
  - Fixed creative format cards display with proper CSS
  - Removed duplicate product lists (simplified navigation)
  - Price guidance shown as range for non-guaranteed products
  - "Tenant" terminology removed from user-facing views
  - Dynamic port configuration (no more hardcoded 8001)
- **Database Schema Updates**:
  - Added `countries` JSONB column to products table
  - Added `implementation_config` JSONB column for adapter data
  - Proper PostgreSQL JSONB handling vs SQLite JSON strings

### Adapter-Specific Configuration UI System
- Each adapter can provide its own configuration UI
- Adapters implement `get_config_ui_endpoint()`, `register_ui_routes()`, and `validate_product_config()`
- Google Ad Manager example with comprehensive UI at `/adapters/gam/config/<tenant_id>/<product_id>`
- Mock adapter UI for testing parameters at `/adapters/mock/config/<tenant_id>/<product_id>`
- Separation of basic product settings from adapter-specific configuration

### Operations Dashboard & Database Persistence
- Added comprehensive operations dashboard in Admin UI
- Moved all operational data to database (media_buys, tasks, audit_logs tables)
- Migrated audit logging from file-based to database-backed with redundancy
- Real-time filtering and monitoring of all media buys and tasks
- Summary metrics showing active campaigns, total spend, pending approvals
- Complete audit trail with security violation tracking
- Database persistence for all MCP operations

### Multi-Tenant Architecture
- Moved from file-based config to database-backed tenant management
- Added `tenants`, `products`, `media_buys`, `creatives` tables
- Implemented subdomain-based routing for tenant isolation
- Created `setup_tenant.py` for easy tenant creation
- Added Admin UI with Google OAuth for secure tenant management

### Advanced Targeting System
- Comprehensive targeting dimensions with adapter mappings
- Two-tier access: overlay (principals) vs managed-only (internal)
- AEE integration via `key_value_pairs` targeting
- Platform-specific targeting translation in each adapter
- Targeting capabilities exposed via MCP tools

### Creative Management System
- Creative groups for organization across campaigns
- Auto-approval for standard formats (configurable per tenant)
- Admin review queue for pending creatives
- Creative association with media packages
- Support for multiple creative formats per buy

### Human-in-the-Loop Support
- Optional manual approval mode per adapter
- Task queue for human review (`human_tasks` table)
- AI verification of task completion
- Async operation support (pending → active states)
- Admin tools for task management

### Security Enhancements
- Comprehensive audit logging with `AuditLogger`
- Principal context tracking for all operations
- Adapter security boundaries documented
- Admin-only tools with separate authentication
- Structured logging for compliance

### Production Features
- PostgreSQL support with connection pooling
- Docker multi-stage builds with health checks
- Environment-based configuration
- Graceful shutdown handling
- Prometheus metrics preparation

## Dependency Management

This project uses **`uv`** for Python dependency management. `uv` is a fast Python package installer and resolver written in Rust.

### Installing Dependencies
```bash
# Install all dependencies (creates .venv automatically)
uv sync

# Add a new dependency
uv add package-name

# Add a development dependency
uv add --dev pytest-asyncio

# Run commands in the virtual environment
uv run python script.py
uv run pytest
```

### Key Dependencies
- **pyproject.toml**: Contains all project dependencies
- **uv.lock**: Lock file ensuring reproducible builds
- Python 3.12+ is required

## Testing Strategy

### 1. Unit Tests
- **`test_ai_product_basic.py`**: Tests default products, industry templates
- **`test_adapters.py`**: Adapter interfaces and base functionality
- **`test_adapter_targeting.py`**: Targeting system validation
- **`test_creative_format_parsing.py`**: Creative format parsing logic

### 2. Integration Tests
- **`test_ai_product_features.py`**: Full AI product feature tests (requires mocking)
- **`test_main.py`**: Core MCP server functionality
- **`test_admin_creative_approval.py`**: Creative approval workflows
- **`test_human_task_queue.py`**: Human-in-the-loop task management
- **`simulation_full.py`**: Full end-to-end campaign lifecycle

### 3. API Tests
- **`test_auth.py`**: Authentication and authorization
- **`tests/unit/test_admin_ui_oauth.py`**: OAuth integration

### Running Tests

#### With uv (Recommended)
```bash
# Run all tests
uv run pytest

# Run specific test file
uv run pytest test_ai_product_basic.py -v

# Run with coverage
uv run pytest --cov=. --cov-report=html

# Run tests by category
uv run python run_tests.py unit       # Unit tests only
uv run python run_tests.py integration # Integration tests
uv run python run_tests.py --list     # List all categories
```

#### In Docker Container
```bash
# Run tests inside the container
docker exec -it adcp-buy-server-adcp-server-1 pytest test_ai_product_basic.py

# Run integration test script
docker exec -it adcp-buy-server-adcp-server-1 ./test_ai_integration.sh
```

#### CI/CD Pipeline
Tests run automatically on push/PR via GitHub Actions:
- Unit tests with mocked dependencies
- Integration tests with PostgreSQL
- AI tests with mocked Gemini API
- See `.github/workflows/test.yml` for details

## Configuration

### Docker Setup (Primary Method)

The system runs with Docker Compose, which manages all services:

```yaml
# docker-compose.yml services:
postgres      # PostgreSQL database
adcp-server   # MCP server on port 8080  
admin-ui      # Admin interface on port 8001
```

**Docker Caching**: The system automatically uses Docker BuildKit caching to speed up builds. Shared volumes (`adcp_global_pip_cache` and `adcp_global_uv_cache`) cache dependencies across all Conductor workspaces, reducing build times from ~2-3 minutes to ~30 seconds.

### Required Configuration (.env file)

```bash
# API Keys
GEMINI_API_KEY=your-gemini-api-key-here

# OAuth Configuration (choose one method)
# Method 1: Environment variables (recommended)
GOOGLE_CLIENT_ID=your-client-id.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=your-client-secret

# Method 2: File path (legacy)
# GOOGLE_OAUTH_CREDENTIALS_FILE=/path/to/client_secret.json

# Admin Configuration
SUPER_ADMIN_EMAILS=user1@example.com,user2@example.com
SUPER_ADMIN_DOMAINS=example.com

# Port Configuration (for Conductor workspaces)
POSTGRES_PORT=5432          # Default: 5432
ADCP_SALES_PORT=8080       # Default: 8080  
ADMIN_UI_PORT=8001         # Default: 8001

# Database Configuration
DATABASE_URL=postgresql://adcp_user:secure_password_change_me@localhost:5432/adcp
```

### Important Configuration Notes

1. **OAuth Setup**: 
   - Prefer environment variables (`GOOGLE_CLIENT_ID` and `GOOGLE_CLIENT_SECRET`)
   - File mounting is legacy - avoid hardcoding paths in docker-compose.yml
   - Admin UI will check environment variables first, then look for client_secret*.json files

2. **Slack Webhooks**: Configure per-tenant in Admin UI, NOT via environment variables

3. **Database**: Docker Compose manages PostgreSQL automatically

4. **Conductor Workspaces**: Each workspace gets unique ports via `.env` file

### Legacy Environment Variables (Standalone Only)

For standalone development without Docker:
- `DATABASE_URL`: Full database connection string
- `DB_TYPE`: Database type: `sqlite` or `postgresql`
- `ADCP_SALES_PORT`: MCP server port (default: 8080)
- `ADMIN_UI_PORT`: Admin UI port (default: 8001)

### Database Schema
```sql
-- Multi-tenant tables
tenants (tenant_id, name, subdomain, config, billing_plan)
principals (tenant_id, principal_id, name, access_token, platform_mappings)
products (tenant_id, product_id, name, formats, targeting_template)
media_buys (tenant_id, media_buy_id, principal_id, status, config, budget, dates)
creatives (tenant_id, creative_id, principal_id, status, format)
creative_associations (media_buy_id, package_id, creative_id)
human_tasks (tenant_id, task_id, task_type, status, assigned_to)
tasks (tenant_id, task_id, media_buy_id, task_type, status, details)
audit_logs (tenant_id, timestamp, operation, principal_id, success, details)
```

### Tenant Configuration
Each tenant has a JSON config in the database:
```json
{
  "adapters": {
    "google_ad_manager": {
      "enabled": true,
      "network_code": "123456",
      "manual_approval_required": false
    }
  },
  "creative_engine": {
    "auto_approve_formats": ["display_300x250"],
    "human_review_required": true
  },
  "features": {
    "max_daily_budget": 10000,
    "enable_aee_signals": true
  },
  "admin_token": "secret_admin_token"
}
```

## Common Operations

### Running the Server (Docker - Recommended)
```bash
# Start all services with Docker Compose
docker-compose up -d

# View logs
docker-compose logs -f

# Stop services
docker-compose down

# Rebuild after code changes
docker-compose build
docker-compose up -d
```

### Running Standalone (Development Only)
```bash
# Install dependencies with uv
uv sync

# Run database migrations
uv run python migrate.py

# Initialize default data (if needed)
uv run python init_database.py

# Start MCP server and Admin UI
uv run python run_server.py
```

### Managing Tenants
```bash
# Create new tenant with default products (inside Docker container)
docker exec -it adcp-buy-server-adcp-server-1 python setup_tenant.py "Publisher Name" \
  --adapter google_ad_manager \
  --gam-network-code 123456 \
  --industry news  # Optional: adds industry-specific products

# Create tenant without default products
docker exec -it adcp-buy-server-adcp-server-1 python setup_tenant.py "Publisher Name" \
  --adapter mock \
  --skip-default-products

# Access Admin UI
open http://localhost:8001
```

### Running Simulations
```bash
# Full lifecycle with temporary test database
uv run python run_simulation.py

# Dry-run with GAM adapter
uv run python run_simulation.py --dry-run --adapter gam

# Use production database (careful!)
uv run python run_simulation.py --use-prod-db

# Run with custom token
uv run python simulation_full.py http://localhost:8080 \
  --token "your_token" \
  --principal "your_principal"

# Demo AI product features
uv run python demo_ai_products.py
```

### Using MCP Client
```python
from fastmcp.client import Client
from fastmcp.client.transports import StreamableHttpTransport

headers = {"x-adcp-auth": "your_token"}
transport = StreamableHttpTransport(url="http://localhost:8080/mcp/", headers=headers)
client = Client(transport=transport)

async with client:
    # Get products
    products = await client.tools.get_products(brief="video ads for sports content")
    
    # Discover available signals (optional)
    signals = await client.tools.get_signals(
        query="sports",
        type="contextual"
    )
    
    # Create media buy with signals
    result = await client.tools.create_media_buy(
        product_ids=["prod_1"],
        total_budget=5000.0,
        flight_start_date="2025-02-01",
        flight_end_date="2025-02-28",
        targeting_overlay={
            "geo_country_any_of": ["US"],
            "signals": ["sports_content", "auto_intenders_q1_2025"]
        }
    )
```

### Product Management APIs
```bash
# Get product suggestions
curl -H "Cookie: session=YOUR_SESSION" \
  "http://localhost:8001/api/tenant/TENANT_ID/products/suggestions?industry=news&max_cpm=20"

# Quick create products from templates
curl -X POST -H "Content-Type: application/json" -H "Cookie: session=YOUR_SESSION" \
  -d '{"product_ids": ["run_of_site_display", "homepage_takeover"]}' \
  "http://localhost:8001/api/tenant/TENANT_ID/products/quick-create"

# Bulk upload products (CSV)
curl -X POST -H "Cookie: session=YOUR_SESSION" \
  -F "file=@products.csv" \
  "http://localhost:8001/api/tenant/TENANT_ID/products/bulk/upload"
```

## Debugging Tips

1. **Authentication Issues**: 
   - Check x-adcp-auth header matches token in principals table
   - Verify tenant_id routing for subdomain access
   - Use Admin UI to view/copy correct tokens

2. **Adapter Errors**: 
   - Enable dry-run mode to see exact API calls
   - Check adapter security documentation in `adapters/*_security.md`
   - Verify platform_mappings in principal record

3. **Targeting Issues**:
   - Review targeting capabilities in `targeting_capabilities.py`
   - Check adapter-specific targeting translation
   - Verify overlay vs managed-only access levels

4. **Database Issues**:
   - PostgreSQL: Check JSONB fields are dicts not strings
   - SQLite: Ensure proper boolean handling (not 0/1)
   - Use correct environment variables for connection

5. **Creative Approval**:
   - Check tenant config for auto_approve_formats
   - Review pending creatives in admin UI
   - Verify creative format matches product specifications

## Key Files for Understanding

- **`main.py`**: MCP server implementation and tool definitions
- **`schemas.py`**: All data models and API contracts
- **`config_loader.py`**: Tenant resolution and configuration
- **`targeting_capabilities.py`**: Complete targeting system definition
- **`audit_logger.py`**: Security logging implementation (now database-backed)
- **`database_schema.py`**: Multi-database schema support
- **`admin_ui.py`**: Flask-based admin interface with operations dashboard
- **`templates/operations.html`**: Operations dashboard UI implementation
- **`ai_product_service.py`**: AI-driven product configuration (uses Gemini 2.5 Flash)
- **`default_products.py`**: Default product templates for new tenants
- **`test_ai_product_basic.py`**: Core AI product feature tests

## Testing Checklist

When making changes, test:
1. ✅ Multi-tenant isolation (create test tenant)
2. ✅ Both SQLite and PostgreSQL databases
3. ✅ Targeting translation for each adapter
4. ✅ Creative approval workflow
5. ✅ Human-in-the-loop task creation
6. ✅ Audit logging for security events (database persistence)
7. ✅ Admin UI with Google OAuth authentication
8. ✅ Operations dashboard functionality (filtering, metrics)
9. ✅ Docker deployment
10. ✅ Media buy persistence to database
11. ✅ Task persistence and status updates
12. ✅ AI product features (templates, bulk upload, suggestions API)
13. ✅ Default product creation for new tenants

## Recent Improvements Summary

1. **Corrected Naming**: "AdCP Sales Agent" (not AdCP:Buy)
2. **Protocol Name**: "Advertising Context Protocol" (not Campaign)
3. **MCP Interface**: Proper MCP examples (not REST/curl)
4. **Test Database**: Simulations use isolated test DB by default
5. **Token Alignment**: Fixed simulation tokens to match database
6. **Documentation**: Comprehensive guides for all features

## Database Migration Best Practices

Based on common issues encountered, follow these guidelines when working with database migrations:

### 1. **Migration File Naming**
- Use consistent revision IDs: `001_description`, `002_description`, etc.
- The revision ID in the filename MUST match the `revision` variable inside the file
- Example: `003_add_policy_compliance_fields.py` should have `revision = '003_add_policy_compliance_fields'`

### 2. **Check Existing Schema First**
- Always check `database_schema.py` to see what columns already exist
- The tenant config is stored in a single `config` JSONB/TEXT column - don't add separate columns for config items
- Use `grep -r "column_name" .` to check if a column already exists before adding it

### 3. **Multi-Database Compatibility**
- Use SQLAlchemy's `sa.table()` and `sa.column()` for data operations in migrations
- Avoid raw SQL strings - they may not work across SQLite and PostgreSQL
- Example of correct approach:
  ```python
  tenants_table = sa.table('tenants',
      sa.column('tenant_id', sa.String),
      sa.column('config', sa.Text)
  )
  connection.execute(tenants_table.update().where(...).values(...))
  ```

### 4. **Testing Migrations**
- Always test with a fresh database: `rm adcp_local.db && uv run python init_database.py`
- Check migration status: `sqlite3 adcp_local.db "SELECT * FROM alembic_version;"`
- If migrations fail, check the error carefully - it often indicates duplicate columns

### 5. **Tenant Configuration Pattern**
- Store feature flags and settings in the tenant's `config` JSON field
- Access via: `tenant.get('config', {}).get('policy_settings')`
- Update `setup_tenant.py` to include new config keys for new tenants
- Example structure:
  ```json
  {
    "adapters": {...},
    "features": {...},
    "policy_settings": {
      "enabled": true,
      "custom_rules": {...}
    }
  }
  ```

### 6. **Boolean Fields in SQLite**
- SQLite doesn't have native boolean type - use `server_default='0'` for False
- PostgreSQL handles booleans properly, but keep SQLite compatibility in mind
- Always test with both databases if making schema changes