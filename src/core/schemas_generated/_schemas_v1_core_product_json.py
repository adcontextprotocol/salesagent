# generated by datamodel-codegen:
#   filename:  _schemas_v1_core_product_json.json
#   timestamp: 2025-10-15T00:10:51+00:00

from __future__ import annotations

from enum import Enum
from typing import Annotated, Literal, Union

from pydantic import AnyUrl, AwareDatetime, BaseModel, ConfigDict, Field, RootModel


class PropertyType(Enum):
    website = "website"
    mobile_app = "mobile_app"
    ctv_app = "ctv_app"
    dooh = "dooh"
    podcast = "podcast"
    radio = "radio"
    streaming_audio = "streaming_audio"


class Type(Enum):
    domain = "domain"
    subdomain = "subdomain"
    network_id = "network_id"
    ios_bundle = "ios_bundle"
    android_package = "android_package"
    apple_app_store_id = "apple_app_store_id"
    google_play_id = "google_play_id"
    roku_store_id = "roku_store_id"
    fire_tv_asin = "fire_tv_asin"
    samsung_app_id = "samsung_app_id"
    apple_tv_bundle = "apple_tv_bundle"
    bundle_id = "bundle_id"
    venue_id = "venue_id"
    screen_id = "screen_id"
    openooh_venue_type = "openooh_venue_type"
    rss_url = "rss_url"
    apple_podcast_id = "apple_podcast_id"
    spotify_show_id = "spotify_show_id"
    podcast_guid = "podcast_guid"


class Identifier(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Annotated[
        Type,
        Field(
            description="Valid identifier types for property identification across different media types",
            examples=["domain", "ios_bundle", "venue_id", "apple_podcast_id"],
            title="Property Identifier Types",
        ),
    ]
    value: Annotated[
        str,
        Field(
            description="The identifier value. For domain type: 'example.com' matches www.example.com and m.example.com only; 'subdomain.example.com' matches that specific subdomain; '*.example.com' matches all subdomains"
        ),
    ]


class Tag(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="Lowercase tag with underscores (e.g., 'conde_nast_network', 'premium_content')",
            pattern="^[a-z0-9_]+$",
        ),
    ]


class Property(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    property_type: Annotated[PropertyType, Field(description="Type of advertising property")]
    name: Annotated[str, Field(description="Human-readable property name")]
    identifiers: Annotated[list[Identifier], Field(description="Array of identifiers for this property", min_length=1)]
    tags: Annotated[
        list[Tag] | None,
        Field(description="Tags for categorization and grouping (e.g., network membership, content categories)"),
    ] = None
    publisher_domain: Annotated[
        str, Field(description="Domain where adagents.json should be checked for authorization validation")
    ]


class PropertyTag(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="Lowercase tag with underscores (e.g., 'local_radio', 'premium_content')",
            pattern="^[a-z0-9_]+$",
        ),
    ]


class FormatId(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    agent_url: Annotated[
        AnyUrl,
        Field(
            description="URL of the agent that defines this format (e.g., 'https://creatives.adcontextprotocol.org' for standard formats, or 'https://publisher.com/.well-known/adcp/sales' for custom formats)"
        ),
    ]
    id: Annotated[
        str,
        Field(
            description="Format identifier within the agent's namespace (e.g., 'display_300x250', 'video_standard_30s')",
            pattern="^[a-zA-Z0-9_-]+$",
        ),
    ]


class DeliveryType(Enum):
    guaranteed = "guaranteed"
    non_guaranteed = "non_guaranteed"


class PricingOptions(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    pricing_option_id: Annotated[
        str,
        Field(description="Unique identifier for this pricing option within the product (e.g., 'cpm_usd_guaranteed')"),
    ]
    pricing_model: Annotated[Literal["cpm"], Field(description="Cost per 1,000 impressions")]
    rate: Annotated[float, Field(description="Fixed CPM rate (cost per 1,000 impressions)", ge=0.0)]
    currency: Annotated[
        str, Field(description="ISO 4217 currency code", examples=["USD", "EUR", "GBP", "JPY"], pattern="^[A-Z]{3}$")
    ]
    min_spend_per_package: Annotated[
        float | None,
        Field(
            description="Minimum spend requirement per package using this pricing option, in the specified currency",
            ge=0.0,
        ),
    ] = None


class PriceGuidance(BaseModel):
    floor: Annotated[
        float, Field(description="Minimum bid price - publisher will reject bids under this value", ge=0.0)
    ]
    p25: Annotated[float | None, Field(description="25th percentile winning price", ge=0.0)] = None
    p50: Annotated[float | None, Field(description="Median winning price", ge=0.0)] = None
    p75: Annotated[float | None, Field(description="75th percentile winning price", ge=0.0)] = None
    p90: Annotated[float | None, Field(description="90th percentile winning price", ge=0.0)] = None


class PricingOptions1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    pricing_option_id: Annotated[
        str, Field(description="Unique identifier for this pricing option within the product (e.g., 'cpm_usd_auction')")
    ]
    pricing_model: Annotated[Literal["cpm"], Field(description="Cost per 1,000 impressions")]
    currency: Annotated[
        str, Field(description="ISO 4217 currency code", examples=["USD", "EUR", "GBP", "JPY"], pattern="^[A-Z]{3}$")
    ]
    price_guidance: Annotated[PriceGuidance, Field(description="Pricing guidance for auction-based CPM bidding")]
    min_spend_per_package: Annotated[
        float | None,
        Field(
            description="Minimum spend requirement per package using this pricing option, in the specified currency",
            ge=0.0,
        ),
    ] = None


class PricingOptions2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    pricing_option_id: Annotated[
        str, Field(description="Unique identifier for this pricing option within the product (e.g., 'cpc_usd_fixed')")
    ]
    pricing_model: Annotated[Literal["cpc"], Field(description="Cost per click")]
    rate: Annotated[float, Field(description="Fixed CPC rate (cost per click)", ge=0.0)]
    currency: Annotated[
        str, Field(description="ISO 4217 currency code", examples=["USD", "EUR", "GBP", "JPY"], pattern="^[A-Z]{3}$")
    ]
    min_spend_per_package: Annotated[
        float | None,
        Field(
            description="Minimum spend requirement per package using this pricing option, in the specified currency",
            ge=0.0,
        ),
    ] = None


class PricingOptions3(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    pricing_option_id: Annotated[
        str,
        Field(description="Unique identifier for this pricing option within the product (e.g., 'cpcv_usd_guaranteed')"),
    ]
    pricing_model: Annotated[Literal["cpcv"], Field(description="Cost per completed view (100% completion)")]
    rate: Annotated[float, Field(description="Fixed CPCV rate (cost per 100% completion)", ge=0.0)]
    currency: Annotated[
        str, Field(description="ISO 4217 currency code", examples=["USD", "EUR", "GBP", "JPY"], pattern="^[A-Z]{3}$")
    ]
    min_spend_per_package: Annotated[
        float | None,
        Field(
            description="Minimum spend requirement per package using this pricing option, in the specified currency",
            ge=0.0,
        ),
    ] = None


class ViewThreshold(RootModel[float]):
    root: Annotated[
        float,
        Field(
            description="Percentage completion threshold for CPV pricing (0.0 to 1.0, e.g., 0.5 = 50% completion)",
            ge=0.0,
            le=1.0,
        ),
    ]


class ViewThreshold3(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    duration_seconds: Annotated[
        int, Field(description="Seconds of viewing required (e.g., 30 for YouTube-style '30 seconds = view')", ge=1)
    ]


class Parameters(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    view_threshold: ViewThreshold | ViewThreshold3


class PricingOptions4(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    pricing_option_id: Annotated[
        str, Field(description="Unique identifier for this pricing option within the product (e.g., 'cpv_usd_50pct')")
    ]
    pricing_model: Annotated[Literal["cpv"], Field(description="Cost per view at threshold")]
    rate: Annotated[float, Field(description="Fixed CPV rate (cost per view)", ge=0.0)]
    currency: Annotated[
        str, Field(description="ISO 4217 currency code", examples=["USD", "EUR", "GBP", "JPY"], pattern="^[A-Z]{3}$")
    ]
    parameters: Annotated[Parameters, Field(description="CPV-specific parameters defining the view threshold")]
    min_spend_per_package: Annotated[
        float | None,
        Field(
            description="Minimum spend requirement per package using this pricing option, in the specified currency",
            ge=0.0,
        ),
    ] = None


class Parameters4(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    demographic: Annotated[
        str,
        Field(
            description="Target demographic in Nielsen format: P/M/W/A/C + age range. Examples: P18-49 (Persons 18-49), M25-54 (Men 25-54), W35+ (Women 35+), A18-34 (Adults 18-34), C2-11 (Children 2-11)",
            pattern="^[PMWAC][0-9]{2}(-[0-9]{2}|\\+)$",
        ),
    ]
    min_points: Annotated[
        float | None, Field(description="Minimum GRPs/TRPs required for this pricing option", ge=0.0)
    ] = None


class PricingOptions5(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    pricing_option_id: Annotated[
        str, Field(description="Unique identifier for this pricing option within the product (e.g., 'cpp_usd_p18-49')")
    ]
    pricing_model: Annotated[Literal["cpp"], Field(description="Cost per Gross Rating Point")]
    rate: Annotated[float, Field(description="Fixed CPP rate (cost per rating point)", ge=0.0)]
    currency: Annotated[
        str, Field(description="ISO 4217 currency code", examples=["USD", "EUR", "GBP", "JPY"], pattern="^[A-Z]{3}$")
    ]
    parameters: Annotated[
        Parameters4, Field(description="CPP-specific parameters for demographic targeting and GRP requirements")
    ]
    min_spend_per_package: Annotated[
        float | None,
        Field(
            description="Minimum spend requirement per package using this pricing option, in the specified currency",
            ge=0.0,
        ),
    ] = None


class Parameters5(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    duration_hours: Annotated[
        float | None, Field(description="Duration in hours for time-based flat rate pricing (DOOH)", ge=0.0)
    ] = None
    sov_percentage: Annotated[
        float | None, Field(description="Guaranteed share of voice as percentage (DOOH, 0-100)", ge=0.0, le=100.0)
    ] = None
    loop_duration_seconds: Annotated[
        int | None, Field(description="Duration of ad loop rotation in seconds (DOOH)", ge=1)
    ] = None
    min_plays_per_hour: Annotated[
        int | None, Field(description="Minimum number of times ad plays per hour (DOOH frequency guarantee)", ge=0)
    ] = None
    venue_package: Annotated[
        str | None,
        Field(
            description="Named venue package identifier for DOOH (e.g., 'times_square_network', 'airport_terminals')"
        ),
    ] = None
    estimated_impressions: Annotated[
        int | None,
        Field(
            description="Estimated impressions for this flat rate option (informational, commonly used with SOV or time-based DOOH)",
            ge=0,
        ),
    ] = None
    daypart: Annotated[
        str | None,
        Field(
            description="Specific daypart for time-based pricing (e.g., 'morning_commute', 'evening_prime', 'overnight')"
        ),
    ] = None


class PricingOptions6(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    pricing_option_id: Annotated[
        str,
        Field(
            description="Unique identifier for this pricing option within the product (e.g., 'flat_rate_usd_24h_takeover')"
        ),
    ]
    pricing_model: Annotated[Literal["flat_rate"], Field(description="Fixed cost regardless of delivery volume")]
    rate: Annotated[float, Field(description="Flat rate cost", ge=0.0)]
    currency: Annotated[
        str, Field(description="ISO 4217 currency code", examples=["USD", "EUR", "GBP", "JPY"], pattern="^[A-Z]{3}$")
    ]
    is_fixed: Annotated[
        Literal[True], Field(description="Whether this is a fixed rate (true) or auction-based (false)")
    ]
    parameters: Annotated[
        Parameters5 | None, Field(description="Flat rate parameters for DOOH and time-based campaigns")
    ] = None
    min_spend_per_package: Annotated[
        float | None,
        Field(
            description="Minimum spend requirement per package using this pricing option, in the specified currency",
            ge=0.0,
        ),
    ] = None


class Measurement(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Annotated[
        str, Field(description="Type of measurement", examples=["incremental_sales_lift", "brand_lift", "foot_traffic"])
    ]
    attribution: Annotated[
        str, Field(description="Attribution methodology", examples=["deterministic_purchase", "probabilistic"])
    ]
    window: Annotated[str | None, Field(description="Attribution window", examples=["30_days", "7_days"])] = None
    reporting: Annotated[
        str, Field(description="Reporting frequency and format", examples=["weekly_dashboard", "real_time_api"])
    ]


class DeliveryMeasurement(BaseModel):
    provider: Annotated[
        str,
        Field(
            description="Measurement provider(s) used for this product (e.g., 'Google Ad Manager with IAS viewability', 'Nielsen DAR', 'Geopath for DOOH impressions')"
        ),
    ]
    notes: Annotated[
        str | None,
        Field(
            description="Additional details about measurement methodology in plain language (e.g., 'MRC-accredited viewability. 50% in-view for 1s display / 2s video', 'Panel-based demographic measurement updated monthly')"
        ),
    ] = None


class AvailableReportingFrequency(Enum):
    hourly = "hourly"
    daily = "daily"
    monthly = "monthly"


class AvailableMetric(Enum):
    impressions = "impressions"
    spend = "spend"
    clicks = "clicks"
    ctr = "ctr"
    video_completions = "video_completions"
    completion_rate = "completion_rate"
    conversions = "conversions"
    viewability = "viewability"
    engagement_rate = "engagement_rate"


class ReportingCapabilities(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    available_reporting_frequencies: Annotated[
        list[AvailableReportingFrequency], Field(description="Supported reporting frequency options", min_length=1)
    ]
    expected_delay_minutes: Annotated[
        int,
        Field(
            description="Expected delay in minutes before reporting data becomes available (e.g., 240 for 4-hour delay)",
            examples=[240, 300, 1440],
            ge=0,
        ),
    ]
    timezone: Annotated[
        str,
        Field(
            description="Timezone for reporting periods. Use 'UTC' or IANA timezone (e.g., 'America/New_York'). Critical for daily/monthly frequency alignment.",
            examples=["UTC", "America/New_York", "Europe/London", "America/Los_Angeles"],
        ),
    ]
    supports_webhooks: Annotated[
        bool, Field(description="Whether this product supports webhook-based reporting notifications")
    ]
    available_metrics: Annotated[
        list[AvailableMetric],
        Field(
            description="Metrics available in reporting. Impressions and spend are always implicitly included.",
            examples=[["impressions", "spend", "clicks", "video_completions"], ["impressions", "spend", "conversions"]],
        ),
    ]


class CoBranding(Enum):
    required = "required"
    optional = "optional"
    none = "none"


class LandingPage(Enum):
    any = "any"
    retailer_site_only = "retailer_site_only"
    must_include_retailer = "must_include_retailer"


class CreativePolicy(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    co_branding: Annotated[CoBranding, Field(description="Co-branding requirement")]
    landing_page: Annotated[LandingPage, Field(description="Landing page requirements")]
    templates_available: Annotated[bool, Field(description="Whether creative templates are provided")]


class Product1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    product_id: Annotated[str, Field(description="Unique identifier for the product")]
    name: Annotated[str, Field(description="Human-readable product name")]
    description: Annotated[str, Field(description="Detailed description of the product and its inventory")]
    properties: Annotated[
        list[Property],
        Field(
            description="Array of advertising properties covered by this product for adagents.json validation",
            min_length=1,
        ),
    ]
    property_tags: Annotated[
        list[PropertyTag] | None,
        Field(
            description="Tags identifying groups of properties covered by this product (use list_authorized_properties to get full property details)",
            min_length=1,
        ),
    ] = None
    format_ids: Annotated[
        list[FormatId],
        Field(
            description="Array of supported creative format IDs - structured format_id objects with agent_url and id"
        ),
    ]
    delivery_type: Annotated[DeliveryType, Field(description="Type of inventory delivery", title="Delivery Type")]
    pricing_options: Annotated[
        list[
            PricingOptions | PricingOptions1 | PricingOptions2 | PricingOptions3 | PricingOptions4 | PricingOptions5 | PricingOptions6
        ],
        Field(description="Available pricing models for this product", min_length=1),
    ]
    estimated_exposures: Annotated[
        int | None, Field(description="Estimated exposures/impressions for guaranteed products", ge=0)
    ] = None
    measurement: Annotated[
        Measurement | None,
        Field(description="Measurement capabilities included with a product", title="Measurement"),
    ] = None
    delivery_measurement: Annotated[
        DeliveryMeasurement,
        Field(
            description="Measurement provider and methodology for delivery metrics. The buyer accepts the declared provider as the source of truth for the buy. REQUIRED for all products."
        ),
    ]
    reporting_capabilities: Annotated[
        ReportingCapabilities | None,
        Field(description="Reporting capabilities available for a product", title="Reporting Capabilities"),
    ] = None
    creative_policy: Annotated[
        CreativePolicy | None,
        Field(description="Creative requirements and restrictions for a product", title="Creative Policy"),
    ] = None
    is_custom: Annotated[bool | None, Field(description="Whether this is a custom product")] = None
    brief_relevance: Annotated[
        str | None,
        Field(description="Explanation of why this product matches the brief (only included when brief is provided)"),
    ] = None
    expires_at: Annotated[AwareDatetime | None, Field(description="Expiration timestamp for custom products")] = None


class Identifier1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Annotated[
        Type,
        Field(
            description="Valid identifier types for property identification across different media types",
            examples=["domain", "ios_bundle", "venue_id", "apple_podcast_id"],
            title="Property Identifier Types",
        ),
    ]
    value: Annotated[
        str,
        Field(
            description="The identifier value. For domain type: 'example.com' matches www.example.com and m.example.com only; 'subdomain.example.com' matches that specific subdomain; '*.example.com' matches all subdomains"
        ),
    ]


class Property1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    property_type: Annotated[PropertyType, Field(description="Type of advertising property")]
    name: Annotated[str, Field(description="Human-readable property name")]
    identifiers: Annotated[list[Identifier1], Field(description="Array of identifiers for this property", min_length=1)]
    tags: Annotated[
        list[Tag] | None,
        Field(description="Tags for categorization and grouping (e.g., network membership, content categories)"),
    ] = None
    publisher_domain: Annotated[
        str, Field(description="Domain where adagents.json should be checked for authorization validation")
    ]


class PricingOptions7(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    pricing_option_id: Annotated[
        str,
        Field(description="Unique identifier for this pricing option within the product (e.g., 'cpm_usd_guaranteed')"),
    ]
    pricing_model: Annotated[Literal["cpm"], Field(description="Cost per 1,000 impressions")]
    rate: Annotated[float, Field(description="Fixed CPM rate (cost per 1,000 impressions)", ge=0.0)]
    currency: Annotated[
        str, Field(description="ISO 4217 currency code", examples=["USD", "EUR", "GBP", "JPY"], pattern="^[A-Z]{3}$")
    ]
    min_spend_per_package: Annotated[
        float | None,
        Field(
            description="Minimum spend requirement per package using this pricing option, in the specified currency",
            ge=0.0,
        ),
    ] = None


class PricingOptions8(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    pricing_option_id: Annotated[
        str, Field(description="Unique identifier for this pricing option within the product (e.g., 'cpm_usd_auction')")
    ]
    pricing_model: Annotated[Literal["cpm"], Field(description="Cost per 1,000 impressions")]
    currency: Annotated[
        str, Field(description="ISO 4217 currency code", examples=["USD", "EUR", "GBP", "JPY"], pattern="^[A-Z]{3}$")
    ]
    price_guidance: Annotated[PriceGuidance, Field(description="Pricing guidance for auction-based CPM bidding")]
    min_spend_per_package: Annotated[
        float | None,
        Field(
            description="Minimum spend requirement per package using this pricing option, in the specified currency",
            ge=0.0,
        ),
    ] = None


class PricingOptions9(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    pricing_option_id: Annotated[
        str, Field(description="Unique identifier for this pricing option within the product (e.g., 'cpc_usd_fixed')")
    ]
    pricing_model: Annotated[Literal["cpc"], Field(description="Cost per click")]
    rate: Annotated[float, Field(description="Fixed CPC rate (cost per click)", ge=0.0)]
    currency: Annotated[
        str, Field(description="ISO 4217 currency code", examples=["USD", "EUR", "GBP", "JPY"], pattern="^[A-Z]{3}$")
    ]
    min_spend_per_package: Annotated[
        float | None,
        Field(
            description="Minimum spend requirement per package using this pricing option, in the specified currency",
            ge=0.0,
        ),
    ] = None


class PricingOptions10(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    pricing_option_id: Annotated[
        str,
        Field(description="Unique identifier for this pricing option within the product (e.g., 'cpcv_usd_guaranteed')"),
    ]
    pricing_model: Annotated[Literal["cpcv"], Field(description="Cost per completed view (100% completion)")]
    rate: Annotated[float, Field(description="Fixed CPCV rate (cost per 100% completion)", ge=0.0)]
    currency: Annotated[
        str, Field(description="ISO 4217 currency code", examples=["USD", "EUR", "GBP", "JPY"], pattern="^[A-Z]{3}$")
    ]
    min_spend_per_package: Annotated[
        float | None,
        Field(
            description="Minimum spend requirement per package using this pricing option, in the specified currency",
            ge=0.0,
        ),
    ] = None


class ViewThreshold4(RootModel[float]):
    root: Annotated[
        float,
        Field(
            description="Percentage completion threshold for CPV pricing (0.0 to 1.0, e.g., 0.5 = 50% completion)",
            ge=0.0,
            le=1.0,
        ),
    ]


class ViewThreshold5(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    duration_seconds: Annotated[
        int, Field(description="Seconds of viewing required (e.g., 30 for YouTube-style '30 seconds = view')", ge=1)
    ]


class Parameters6(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    view_threshold: ViewThreshold4 | ViewThreshold5


class PricingOptions11(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    pricing_option_id: Annotated[
        str, Field(description="Unique identifier for this pricing option within the product (e.g., 'cpv_usd_50pct')")
    ]
    pricing_model: Annotated[Literal["cpv"], Field(description="Cost per view at threshold")]
    rate: Annotated[float, Field(description="Fixed CPV rate (cost per view)", ge=0.0)]
    currency: Annotated[
        str, Field(description="ISO 4217 currency code", examples=["USD", "EUR", "GBP", "JPY"], pattern="^[A-Z]{3}$")
    ]
    parameters: Annotated[Parameters6, Field(description="CPV-specific parameters defining the view threshold")]
    min_spend_per_package: Annotated[
        float | None,
        Field(
            description="Minimum spend requirement per package using this pricing option, in the specified currency",
            ge=0.0,
        ),
    ] = None


class Parameters7(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    demographic: Annotated[
        str,
        Field(
            description="Target demographic in Nielsen format: P/M/W/A/C + age range. Examples: P18-49 (Persons 18-49), M25-54 (Men 25-54), W35+ (Women 35+), A18-34 (Adults 18-34), C2-11 (Children 2-11)",
            pattern="^[PMWAC][0-9]{2}(-[0-9]{2}|\\+)$",
        ),
    ]
    min_points: Annotated[
        float | None, Field(description="Minimum GRPs/TRPs required for this pricing option", ge=0.0)
    ] = None


class PricingOptions12(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    pricing_option_id: Annotated[
        str, Field(description="Unique identifier for this pricing option within the product (e.g., 'cpp_usd_p18-49')")
    ]
    pricing_model: Annotated[Literal["cpp"], Field(description="Cost per Gross Rating Point")]
    rate: Annotated[float, Field(description="Fixed CPP rate (cost per rating point)", ge=0.0)]
    currency: Annotated[
        str, Field(description="ISO 4217 currency code", examples=["USD", "EUR", "GBP", "JPY"], pattern="^[A-Z]{3}$")
    ]
    parameters: Annotated[
        Parameters7, Field(description="CPP-specific parameters for demographic targeting and GRP requirements")
    ]
    min_spend_per_package: Annotated[
        float | None,
        Field(
            description="Minimum spend requirement per package using this pricing option, in the specified currency",
            ge=0.0,
        ),
    ] = None


class Parameters8(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    duration_hours: Annotated[
        float | None, Field(description="Duration in hours for time-based flat rate pricing (DOOH)", ge=0.0)
    ] = None
    sov_percentage: Annotated[
        float | None, Field(description="Guaranteed share of voice as percentage (DOOH, 0-100)", ge=0.0, le=100.0)
    ] = None
    loop_duration_seconds: Annotated[
        int | None, Field(description="Duration of ad loop rotation in seconds (DOOH)", ge=1)
    ] = None
    min_plays_per_hour: Annotated[
        int | None, Field(description="Minimum number of times ad plays per hour (DOOH frequency guarantee)", ge=0)
    ] = None
    venue_package: Annotated[
        str | None,
        Field(
            description="Named venue package identifier for DOOH (e.g., 'times_square_network', 'airport_terminals')"
        ),
    ] = None
    estimated_impressions: Annotated[
        int | None,
        Field(
            description="Estimated impressions for this flat rate option (informational, commonly used with SOV or time-based DOOH)",
            ge=0,
        ),
    ] = None
    daypart: Annotated[
        str | None,
        Field(
            description="Specific daypart for time-based pricing (e.g., 'morning_commute', 'evening_prime', 'overnight')"
        ),
    ] = None


class PricingOptions13(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    pricing_option_id: Annotated[
        str,
        Field(
            description="Unique identifier for this pricing option within the product (e.g., 'flat_rate_usd_24h_takeover')"
        ),
    ]
    pricing_model: Annotated[Literal["flat_rate"], Field(description="Fixed cost regardless of delivery volume")]
    rate: Annotated[float, Field(description="Flat rate cost", ge=0.0)]
    currency: Annotated[
        str, Field(description="ISO 4217 currency code", examples=["USD", "EUR", "GBP", "JPY"], pattern="^[A-Z]{3}$")
    ]
    is_fixed: Annotated[
        Literal[True], Field(description="Whether this is a fixed rate (true) or auction-based (false)")
    ]
    parameters: Annotated[
        Parameters8 | None, Field(description="Flat rate parameters for DOOH and time-based campaigns")
    ] = None
    min_spend_per_package: Annotated[
        float | None,
        Field(
            description="Minimum spend requirement per package using this pricing option, in the specified currency",
            ge=0.0,
        ),
    ] = None


class ReportingCapabilities1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    available_reporting_frequencies: Annotated[
        list[AvailableReportingFrequency], Field(description="Supported reporting frequency options", min_length=1)
    ]
    expected_delay_minutes: Annotated[
        int,
        Field(
            description="Expected delay in minutes before reporting data becomes available (e.g., 240 for 4-hour delay)",
            examples=[240, 300, 1440],
            ge=0,
        ),
    ]
    timezone: Annotated[
        str,
        Field(
            description="Timezone for reporting periods. Use 'UTC' or IANA timezone (e.g., 'America/New_York'). Critical for daily/monthly frequency alignment.",
            examples=["UTC", "America/New_York", "Europe/London", "America/Los_Angeles"],
        ),
    ]
    supports_webhooks: Annotated[
        bool, Field(description="Whether this product supports webhook-based reporting notifications")
    ]
    available_metrics: Annotated[
        list[AvailableMetric],
        Field(
            description="Metrics available in reporting. Impressions and spend are always implicitly included.",
            examples=[["impressions", "spend", "clicks", "video_completions"], ["impressions", "spend", "conversions"]],
        ),
    ]


class CreativePolicy2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    co_branding: Annotated[CoBranding, Field(description="Co-branding requirement")]
    landing_page: Annotated[LandingPage, Field(description="Landing page requirements")]
    templates_available: Annotated[bool, Field(description="Whether creative templates are provided")]


class Product2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    product_id: Annotated[str, Field(description="Unique identifier for the product")]
    name: Annotated[str, Field(description="Human-readable product name")]
    description: Annotated[str, Field(description="Detailed description of the product and its inventory")]
    properties: Annotated[
        list[Property1] | None,
        Field(
            description="Array of advertising properties covered by this product for adagents.json validation",
            min_length=1,
        ),
    ] = None
    property_tags: Annotated[
        list[PropertyTag],
        Field(
            description="Tags identifying groups of properties covered by this product (use list_authorized_properties to get full property details)",
            min_length=1,
        ),
    ]
    format_ids: Annotated[
        list[FormatId],
        Field(
            description="Array of supported creative format IDs - structured format_id objects with agent_url and id"
        ),
    ]
    delivery_type: Annotated[DeliveryType, Field(description="Type of inventory delivery", title="Delivery Type")]
    pricing_options: Annotated[
        list[
            PricingOptions7 | PricingOptions8 | PricingOptions9 | PricingOptions10 | PricingOptions11 | PricingOptions12 | PricingOptions13
        ],
        Field(description="Available pricing models for this product", min_length=1),
    ]
    estimated_exposures: Annotated[
        int | None, Field(description="Estimated exposures/impressions for guaranteed products", ge=0)
    ] = None
    measurement: Annotated[
        Measurement | None,
        Field(description="Measurement capabilities included with a product", title="Measurement"),
    ] = None
    delivery_measurement: Annotated[
        DeliveryMeasurement,
        Field(
            description="Measurement provider and methodology for delivery metrics. The buyer accepts the declared provider as the source of truth for the buy. REQUIRED for all products."
        ),
    ]
    reporting_capabilities: Annotated[
        ReportingCapabilities1 | None,
        Field(description="Reporting capabilities available for a product", title="Reporting Capabilities"),
    ] = None
    creative_policy: Annotated[
        CreativePolicy2 | None,
        Field(description="Creative requirements and restrictions for a product", title="Creative Policy"),
    ] = None
    is_custom: Annotated[bool | None, Field(description="Whether this is a custom product")] = None
    brief_relevance: Annotated[
        str | None,
        Field(description="Explanation of why this product matches the brief (only included when brief is provided)"),
    ] = None
    expires_at: Annotated[AwareDatetime | None, Field(description="Expiration timestamp for custom products")] = None


class Product(RootModel[Union[Product1, Product2]]):
    root: Annotated[
        Product1 | Product2, Field(description="Represents available advertising inventory", title="Product")
    ]
