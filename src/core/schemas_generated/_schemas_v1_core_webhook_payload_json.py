# generated by datamodel-codegen:
#   filename:  _schemas_v1_core_webhook-payload_json.json
#   schema_hash: 3f75e0d93032

from __future__ import annotations

from enum import Enum
from typing import Annotated, Any

from pydantic import AnyUrl, AwareDatetime, BaseModel, ConfigDict, Field


class TaskType(Enum):
    create_media_buy = "create_media_buy"
    update_media_buy = "update_media_buy"
    sync_creatives = "sync_creatives"
    activate_signal = "activate_signal"
    get_signals = "get_signals"


class Domain(Enum):
    media_buy = "media-buy"
    signals = "signals"


class Status(Enum):
    submitted = "submitted"
    working = "working"
    input_required = "input-required"
    completed = "completed"
    canceled = "canceled"
    failed = "failed"
    rejected = "rejected"
    auth_required = "auth-required"
    unknown = "unknown"


class Progress(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    percentage: Annotated[float | None, Field(description="Completion percentage (0-100)", ge=0.0, le=100.0)] = None
    current_step: Annotated[str | None, Field(description="Current step or phase of the operation")] = None
    total_steps: Annotated[int | None, Field(description="Total number of steps in the operation", ge=1)] = None
    step_number: Annotated[int | None, Field(description="Current step number", ge=1)] = None


class Package(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    package_id: Annotated[str, Field(description="Publisher's unique identifier for the package")]
    buyer_ref: Annotated[str, Field(description="Buyer's reference identifier for the package")]


class Error(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    code: Annotated[str, Field(description="Error code for programmatic handling")]
    message: Annotated[str, Field(description="Human-readable error message")]
    field: Annotated[
        str | None, Field(description="Field path associated with the error (e.g., 'packages[0].targeting')")
    ] = None
    suggestion: Annotated[str | None, Field(description="Suggested fix for the error")] = None
    retry_after: Annotated[float | None, Field(description="Seconds to wait before retrying the operation", ge=0.0)] = (
        None
    )
    details: Annotated[Any | None, Field(description="Additional task-specific error details")] = None


class Result(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    media_buy_id: Annotated[
        str | None, Field(description="Publisher's unique identifier for the created media buy")
    ] = None
    buyer_ref: Annotated[str, Field(description="Buyer's reference identifier for this media buy")]
    creative_deadline: Annotated[
        AwareDatetime | None, Field(description="ISO 8601 timestamp for creative upload deadline")
    ] = None
    packages: Annotated[list[Package] | None, Field(description="Array of created packages")] = None
    errors: Annotated[
        list[Error] | None,
        Field(description="Task-specific errors and warnings (e.g., partial package creation failures)"),
    ] = None


class AffectedPackage(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    package_id: Annotated[str, Field(description="Publisher's package identifier")]
    buyer_ref: Annotated[str, Field(description="Buyer's reference for the package")]


class Result1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    media_buy_id: Annotated[str, Field(description="Publisher's identifier for the media buy")]
    buyer_ref: Annotated[str, Field(description="Buyer's reference identifier for the media buy")]
    implementation_date: Annotated[
        AwareDatetime | None,
        Field(description="ISO 8601 timestamp when changes take effect (null if pending approval)"),
    ] = None
    affected_packages: Annotated[
        list[AffectedPackage] | None, Field(description="Array of packages that were modified")
    ] = None
    errors: Annotated[
        list[Any] | None, Field(description="Task-specific errors and warnings (e.g., partial update failures)")
    ] = None


class Action(Enum):
    created = "created"
    updated = "updated"
    unchanged = "unchanged"
    failed = "failed"
    deleted = "deleted"


class Creative(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    creative_id: Annotated[str, Field(description="Creative ID from the request")]
    action: Annotated[Action, Field(description="Action taken for this creative")]
    platform_id: Annotated[str | None, Field(description="Platform-specific ID assigned to the creative")] = None
    changes: Annotated[
        list[str] | None, Field(description="Field names that were modified (only present when action='updated')")
    ] = None
    errors: Annotated[
        list[str] | None, Field(description="Validation or processing errors (only present when action='failed')")
    ] = None
    warnings: Annotated[list[str] | None, Field(description="Non-fatal warnings about this creative")] = None
    preview_url: Annotated[
        AnyUrl | None, Field(description="Preview URL for generative creatives (only present for generative formats)")
    ] = None
    expires_at: Annotated[
        AwareDatetime | None,
        Field(description="ISO 8601 timestamp when preview link expires (only present when preview_url exists)"),
    ] = None
    assigned_to: Annotated[
        list[str] | None,
        Field(
            description="Package IDs this creative was successfully assigned to (only present when assignments were requested)"
        ),
    ] = None
    assignment_errors: Annotated[
        dict[str, str] | None,
        Field(description="Assignment errors by package ID (only present when assignment failures occurred)"),
    ] = None


class Result2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    dry_run: Annotated[bool | None, Field(description="Whether this was a dry run (no actual changes made)")] = None
    creatives: Annotated[list[Creative], Field(description="Results for each creative processed")]


class Result3(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    decisioning_platform_segment_id: Annotated[
        str | None, Field(description="The platform-specific ID to use once activated")
    ] = None
    estimated_activation_duration_minutes: Annotated[
        float | None, Field(description="Estimated time to complete (optional)", ge=0.0)
    ] = None
    deployed_at: Annotated[
        AwareDatetime | None, Field(description="Timestamp when activation completed (optional)")
    ] = None
    errors: Annotated[
        list[Any] | None,
        Field(description="Task-specific errors and warnings (e.g., activation failures, platform issues)"),
    ] = None


class SignalType(Enum):
    marketplace = "marketplace"
    custom = "custom"
    owned = "owned"


class Scope(Enum):
    platform_wide = "platform-wide"
    account_specific = "account-specific"


class Deployment(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    platform: Annotated[str, Field(description="Platform name")]
    account: Annotated[str | None, Field(description="Specific account if applicable")] = None
    is_live: Annotated[bool, Field(description="Whether signal is currently active")]
    scope: Annotated[Scope, Field(description="Deployment scope")]
    decisioning_platform_segment_id: Annotated[str | None, Field(description="Platform-specific segment ID")] = None
    estimated_activation_duration_minutes: Annotated[
        float | None, Field(description="Time to activate if not live", ge=0.0)
    ] = None


class Pricing(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    cpm: Annotated[float, Field(description="Cost per thousand impressions", ge=0.0)]
    currency: Annotated[str, Field(description="Currency code", pattern="^[A-Z]{3}$")]


class Signal(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    signal_agent_segment_id: Annotated[str, Field(description="Unique identifier for the signal")]
    name: Annotated[str, Field(description="Human-readable signal name")]
    description: Annotated[str, Field(description="Detailed signal description")]
    signal_type: Annotated[SignalType, Field(description="Type of signal")]
    data_provider: Annotated[str, Field(description="Name of the data provider")]
    coverage_percentage: Annotated[float, Field(description="Percentage of audience coverage", ge=0.0, le=100.0)]
    deployments: Annotated[list[Deployment], Field(description="Array of platform deployments")]
    pricing: Annotated[Pricing, Field(description="Pricing information")]


class Result4(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    signals: Annotated[list[Signal], Field(description="Array of matching signals")]
    errors: Annotated[
        list[Any] | None,
        Field(description="Task-specific errors and warnings (e.g., signal discovery or pricing issues)"),
    ] = None


class WebhookPayload(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    operation_id: Annotated[
        str | None,
        Field(
            description="Publisher-defined operation identifier correlating a sequence of task updates across webhooks."
        ),
    ] = None
    task_id: Annotated[
        str,
        Field(
            description="Unique identifier for this task. Use this to correlate webhook notifications with the original task submission."
        ),
    ]
    task_type: Annotated[
        TaskType,
        Field(
            description="Valid AdCP task types across all domains. These represent the complete set of operations that can be tracked via the task management system.",
            title="Task Type",
        ),
    ]
    domain: Annotated[
        Domain | None,
        Field(description="AdCP domain this task belongs to. Helps classify the operation type at a high level."),
    ] = None
    status: Annotated[
        Status,
        Field(
            description="Standardized task status values based on A2A TaskState enum. Indicates the current state of any AdCP operation.",
            title="Task Status",
        ),
    ]
    timestamp: Annotated[AwareDatetime, Field(description="ISO 8601 timestamp when this webhook was generated.")]
    message: Annotated[
        str | None,
        Field(
            description="Human-readable summary of the current task state. Provides context about what happened and what action may be needed."
        ),
    ] = None
    context_id: Annotated[
        str | None,
        Field(
            description="Session/conversation identifier. Use this to continue the conversation if input-required status needs clarification or additional parameters."
        ),
    ] = None
    progress: Annotated[
        Progress | None,
        Field(
            description="Progress information for tasks still in 'working' state. Rarely seen in webhooks since 'working' tasks typically complete synchronously, but may appear if a task transitions from 'submitted' to 'working'."
        ),
    ] = None
    result: Annotated[
        Result | Result1 | Result2 | Result3 | Result4 | None,
        Field(
            description="Task-specific payload for this status update. For 'completed', contains the final result. For 'input-required', may contain approval or clarification context. Optional for non-terminal updates."
        ),
    ] = None
    error: Annotated[
        str | None, Field(description="Error message for failed tasks. Only present when status is 'failed'.")
    ] = None
