# generated by datamodel-codegen:
#   filename:  _schemas_v1_media-buy_list-creative-formats-response_json.json
#   timestamp: 2025-10-15T12:36:38+00:00

from __future__ import annotations

from enum import Enum
from typing import Annotated, Any

from pydantic import AnyUrl, BaseModel, ConfigDict, Field


class Type(Enum):
    audio = "audio"
    video = "video"
    display = "display"
    native = "native"
    dooh = "dooh"
    rich_media = "rich_media"
    universal = "universal"


class Responsive(BaseModel):
    width: bool
    height: bool


class Unit(Enum):
    px = "px"
    dp = "dp"
    inches = "inches"
    cm = "cm"


class Dimensions(BaseModel):
    width: Annotated[float | None, Field(description="Fixed width in specified units", ge=0.0)] = None
    height: Annotated[float | None, Field(description="Fixed height in specified units", ge=0.0)] = None
    min_width: Annotated[float | None, Field(description="Minimum width for responsive renders", ge=0.0)] = None
    min_height: Annotated[float | None, Field(description="Minimum height for responsive renders", ge=0.0)] = None
    max_width: Annotated[float | None, Field(description="Maximum width for responsive renders", ge=0.0)] = None
    max_height: Annotated[float | None, Field(description="Maximum height for responsive renders", ge=0.0)] = None
    responsive: Annotated[Responsive | None, Field(description="Indicates which dimensions are responsive/fluid")] = (
        None
    )
    aspect_ratio: Annotated[
        str | None,
        Field(description="Fixed aspect ratio constraint (e.g., '16:9', '4:3', '1:1')", pattern="^\\d+:\\d+$"),
    ] = None
    unit: Annotated[Unit, Field(description="Unit of measurement for dimensions")]


class Render(BaseModel):
    role: Annotated[
        str, Field(description="Semantic role of this rendered piece (e.g., 'primary', 'companion', 'mobile_variant')")
    ]
    dimensions: Annotated[Dimensions, Field(description="Dimensions for this rendered piece")]


class AssetType(Enum):
    image = "image"
    video = "video"
    audio = "audio"
    text = "text"
    html = "html"
    javascript = "javascript"
    url = "url"
    brand_manifest = "brand_manifest"


class AssetsRequired(BaseModel):
    asset_id: Annotated[str, Field(description="Identifier for this asset in the format")]
    asset_type: Annotated[AssetType, Field(description="Type of asset")]
    asset_role: Annotated[
        str | None, Field(description="Purpose of this asset (e.g., 'hero_image', 'logo', 'headline', 'cta_button')")
    ] = None
    required: Annotated[bool | None, Field(description="Whether this asset is required")] = None
    requirements: Annotated[
        dict[str, Any] | None,
        Field(description="Technical requirements for this asset (dimensions, file size, duration, etc.)"),
    ] = None


class Repeatable(Enum):
    boolean_true = True


class Asset(BaseModel):
    asset_id: Annotated[str, Field(description="Identifier for this asset within the group")]
    asset_type: Annotated[AssetType, Field(description="Type of asset")]
    asset_role: Annotated[str | None, Field(description="Purpose of this asset")] = None
    required: Annotated[bool | None, Field(description="Whether this asset is required in each repetition")] = None
    requirements: Annotated[dict[str, Any] | None, Field(description="Technical requirements for this asset")] = None


class AssetsRequired3(BaseModel):
    asset_group_id: Annotated[
        str, Field(description="Identifier for this asset group (e.g., 'product', 'slide', 'card')")
    ]
    repeatable: Annotated[Repeatable, Field(description="Indicates this is a repeatable asset group")]
    min_count: Annotated[int, Field(description="Minimum number of repetitions required", ge=1)]
    max_count: Annotated[int, Field(description="Maximum number of repetitions allowed", ge=1)]
    assets: Annotated[list[Asset], Field(description="Assets within each repetition of this group")]


class Format(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    format_id: Annotated[str, Field(description="Unique identifier for the format")]
    agent_url: Annotated[
        AnyUrl | None,
        Field(
            description="Base URL of the agent that provides this format (authoritative source). E.g., 'https://reference.adcp.org', 'https://dco.example.com'"
        ),
    ] = None
    name: Annotated[str, Field(description="Human-readable format name")]
    description: Annotated[
        str | None, Field(description="Plain text explanation of what this format does and what assets it requires")
    ] = None
    preview_image: Annotated[
        AnyUrl | None,
        Field(
            description="Optional preview image URL for format browsing/discovery UI. Should be 400x300px (4:3 aspect ratio) PNG or JPG. Used as thumbnail/card image in format browsers."
        ),
    ] = None
    example_url: Annotated[
        AnyUrl | None,
        Field(description="Optional URL to showcase page with examples and interactive demos of this format"),
    ] = None
    type: Annotated[
        Type, Field(description="Media type of this format - determines rendering method and asset requirements")
    ]
    renders: Annotated[
        list[Render] | None,
        Field(
            description="Specification of rendered pieces for this format. Most formats produce a single render. Companion ad formats (video + banner), adaptive formats, and multi-placement formats produce multiple renders. Each render specifies its role and dimensions.",
            min_length=1,
        ),
    ] = None
    assets_required: Annotated[
        list[AssetsRequired | AssetsRequired3] | None,
        Field(
            description="Array of required assets or asset groups for this format. Can contain individual assets or repeatable asset sequences (e.g., carousel products, slideshow frames)."
        ),
    ] = None
    delivery: Annotated[
        dict[str, Any] | None,
        Field(description="Delivery method specifications (e.g., hosted, VAST, third-party tags)"),
    ] = None
    supported_macros: Annotated[
        list[str] | None,
        Field(
            description="List of universal macros supported by this format (e.g., MEDIA_BUY_ID, CACHEBUSTER, DEVICE_ID). Used for validation and developer tooling."
        ),
    ] = None
    output_format_ids: Annotated[
        list[str] | None,
        Field(
            description="For generative formats: array of format IDs that this format can generate. When a format accepts inputs like brand_manifest and message, this specifies what concrete output formats can be produced (e.g., a generative banner format might output standard image banner formats)."
        ),
    ] = None


class Capability(Enum):
    validation = "validation"
    assembly = "assembly"
    generation = "generation"
    preview = "preview"


class CreativeAgent(BaseModel):
    agent_url: Annotated[
        AnyUrl,
        Field(
            description="Base URL for the creative agent (e.g., 'https://reference.adcp.org', 'https://dco.example.com'). Call list_creative_formats on this URL to get its formats."
        ),
    ]
    agent_name: Annotated[str | None, Field(description="Human-readable name for the creative agent")] = None
    capabilities: Annotated[list[Capability] | None, Field(description="Capabilities this creative agent provides")] = (
        None
    )


class Error(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    code: Annotated[str, Field(description="Error code for programmatic handling")]
    message: Annotated[str, Field(description="Human-readable error message")]
    field: Annotated[
        str | None, Field(description="Field path associated with the error (e.g., 'packages[0].targeting')")
    ] = None
    suggestion: Annotated[str | None, Field(description="Suggested fix for the error")] = None
    retry_after: Annotated[float | None, Field(description="Seconds to wait before retrying the operation", ge=0.0)] = (
        None
    )
    details: Annotated[Any | None, Field(description="Additional task-specific error details")] = None


class ListCreativeFormatsResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    formats: Annotated[
        list[Format],
        Field(
            description="Full format definitions for all formats this agent supports. Each format's authoritative source is indicated by its agent_url field."
        ),
    ]
    creative_agents: Annotated[
        list[CreativeAgent] | None,
        Field(
            description="Optional: Creative agents that provide additional formats. Buyers can recursively query these agents to discover more formats. No authentication required for list_creative_formats."
        ),
    ] = None
    errors: Annotated[
        list[Error] | None, Field(description="Task-specific errors and warnings (e.g., format availability issues)")
    ] = None
