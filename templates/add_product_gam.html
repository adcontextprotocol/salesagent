{% extends "base.html" %}

{% block title %}{{ 'Edit' if product else 'Create' }} Product - Google Ad Manager{% endblock %}

{% block content %}
<div class="card">
    <h2>{{ 'Edit' if product else 'Create' }} Product (Google Ad Manager)</h2>

    {% if not inventory_synced %}
    <div class="alert alert-warning" style="margin-bottom: 2rem; padding: 1rem; background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px;">
        <h4 style="margin-top: 0; color: #856404;">‚ö†Ô∏è Inventory Not Synced</h4>
        <p style="margin-bottom: 1rem;">GAM inventory has not been synced yet. You won't be able to select ad units or placements until inventory is synced.</p>
        <a href="{{ url_for('inventory.inventory_browser', tenant_id=tenant_id) }}" class="btn btn-primary">
            üìä Go to Inventory Browser to Sync
        </a>
    </div>
    {% endif %}

    <form id="product-form" method="POST" onsubmit="debugFormSubmission(event)">
        <!-- Section 1: Product Basics -->
        <h3 style="margin-top: 0; border-bottom: 2px solid #007bff; padding-bottom: 0.5rem;">Product Information</h3>
        <p style="color: #666; margin-bottom: 1.5rem;">Basic product details that buyers will see</p>

        <div class="form-group">
            <label for="name">Product Name *</label>
            <input type="text" id="name" name="name" required placeholder="e.g., Premium Homepage Package" value="{{ product.name if product else '' }}">
        </div>

        <div class="form-group">
            <label for="description">Description</label>
            <textarea id="description" name="description" rows="3" placeholder="Describe this product for potential buyers">{{ product.description if product else '' }}</textarea>
        </div>

        <div class="form-group">
            <label for="countries">Countries</label>
            <select id="countries" name="countries" multiple size="5">
                <option value="ALL">All Countries</option>
                <option value="United States">United States</option>
                <option value="Canada">Canada</option>
                <option value="United Kingdom">United Kingdom</option>
                <option value="Australia">Australia</option>
            </select>
            <small style="color: #666;">Hold Ctrl/Cmd to select multiple, or select "All Countries"</small>
        </div>

        <!-- Section 2: GAM Inventory Selection -->
        <h3 style="margin-top: 2rem; border-bottom: 2px solid #007bff; padding-bottom: 0.5rem;">GAM Inventory</h3>
        <p style="color: #666; margin-bottom: 1.5rem;">Select ad units and placements from your GAM inventory</p>

        <div class="form-group">
            <label for="ad-unit-search">Ad Units</label>
            <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                <input type="text" id="ad-unit-search" placeholder="Search ad units..." style="flex: 1;">
                <button type="button" onclick="openInventoryPicker('ad_unit')" class="btn btn-secondary" {% if not inventory_synced %}disabled{% endif %}>
                    Browse Ad Units
                </button>
            </div>
            <div id="selected-ad-units" style="min-height: 60px; border: 1px solid #ddd; border-radius: 4px; padding: 0.5rem; background: #f9f9f9;">
                <span style="color: #999;">No ad units selected</span>
            </div>
            <textarea id="targeted_ad_unit_ids" name="targeted_ad_unit_ids" style="display: none;"></textarea>
        </div>

        <div class="form-group">
            <label for="placement-search">Placements</label>
            <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                <input type="text" id="placement-search" placeholder="Search placements..." style="flex: 1;">
                <button type="button" onclick="openInventoryPicker('placement')" class="btn btn-secondary" {% if not inventory_synced %}disabled{% endif %}>
                    Browse Placements
                </button>
            </div>
            <div id="selected-placements" style="min-height: 60px; border: 1px solid #ddd; border-radius: 4px; padding: 0.5rem; background: #f9f9f9;">
                <span style="color: #999;">No placements selected</span>
            </div>
            <textarea id="targeted_placement_ids" name="targeted_placement_ids" style="display: none;"></textarea>
        </div>

        <div class="form-group">
            <label>
                <input type="checkbox" name="include_descendants" checked>
                Include child ad units in targeting
            </label>
        </div>

        <!-- Section 3: Creative Formats -->
        <h3 style="margin-top: 2rem; border-bottom: 2px solid #007bff; padding-bottom: 0.5rem;">Creative Formats</h3>
        <p style="color: #666; margin-bottom: 1rem;">Choose creative formats for this product. Click the ‚ìò icon on each format to learn more.</p>

        <!-- Search box for formats -->
        <div id="format-search-box" style="margin-bottom: 1rem;">
            <input type="text" id="format-search-input" placeholder="Search formats by name, type, or size..."
                   style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;"
                   onkeyup="filterGAMFormats()">
        </div>

        <!-- Size filter panel (shown when inventory selected) -->
        <div id="size-filter-panel" style="display: none; margin-bottom: 1rem; padding: 1rem; background: #f0f7ff; border: 2px solid #d0e7ff; border-radius: 6px;">
            <strong style="color: #1976d2; margin-bottom: 0.75rem; display: block;">üí° Sizes from your selected inventory:</strong>
            <div id="size-chips-container" style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 0.75rem;">
                <!-- Size chips populated by JavaScript -->
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <span id="matching-formats-count" style="color: #666; font-size: 0.9rem;">0 matching / 0 total formats</span>
                <label style="display: flex; align-items: center; gap: 0.5rem; margin: 0; cursor: pointer;">
                    <input type="checkbox" id="show-only-matching-toggle" onchange="toggleShowOnlyMatching()">
                    <span style="font-size: 0.9rem;">Show only matching</span>
                </label>
            </div>
        </div>

        <!-- Size-type combos being searched (shown after ad units selected) -->
        <div id="format-search-targets" style="display: none; padding: 1rem; background: #e7f3ff; border: 1px solid #90caf9; border-radius: 4px; margin-bottom: 1rem;">
            <strong style="color: #1565c0;">Looking for formats:</strong>
            <div id="search-target-list" style="margin-top: 0.5rem; display: flex; flex-wrap: wrap; gap: 0.5rem;"></div>
        </div>

        <!-- Format selection actions (shown with formats) -->
        <div id="format-actions" style="display: flex; gap: 0.5rem; margin-bottom: 1rem; align-items: center; flex-wrap: wrap;">
            <button type="button" id="select-all-formats-btn" class="btn btn-secondary btn-sm" onclick="selectAllFormats()">
                ‚úì Select All
            </button>
            <button type="button" id="select-matching-formats-btn" class="btn btn-primary btn-sm" onclick="selectAllMatchingFormats()" style="display: none;">
                ‚úì Select All Matching
            </button>
            <button type="button" id="deselect-all-formats-btn" class="btn btn-secondary btn-sm" onclick="deselectAllFormats()">
                ‚úó Deselect All
            </button>
            <span style="color: #666; font-size: 0.85rem; margin-left: 0.5rem;">Select formats that match your inventory</span>
        </div>

        <!-- Formats container (always visible) -->
        <div id="formats-container" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 1rem; margin-bottom: 1rem; max-height: 500px; overflow-y: auto; padding: 1rem; background: #f9f9f9; border: 1px solid #ddd; border-radius: 4px;">
            {% for format in formats %}
            <label class="format-card"
                   data-format-id="{{ format.id }}"
                   data-dimensions="{{ format.dimensions or '' }}"
                   data-type="{{ format.type }}"
                   data-description="{{ format.description or '' }}"
                   data-preview-url="{{ format.preview_url or '' }}"
                   data-agent-url="{{ format.agent_url or '' }}"
                   data-search="{{ format.name|lower }} {{ format.type|lower }} {{ format.dimensions or '' }}"
                   style="border: 2px solid #ddd; border-radius: 4px; padding: 1rem; cursor: pointer; transition: all 0.2s; background: white; position: relative;">
                <input type="checkbox" name="formats" value="{{ format.agent_url }}|{{ format.id }}" data-format-id="{{ format.id }}" data-agent-url="{{ format.agent_url }}" {% if selected_format_ids and (format.agent_url, format.id) in selected_format_ids %}checked{% endif %} style="margin-right: 0.5rem;">
                <strong>{{ format.name }}</strong>
                <span class="format-info-icon" onclick="event.preventDefault(); event.stopPropagation(); showFormatInfo({{ format.name | tojson }}, {{ (format.description or 'No description available') | tojson }}, {{ (format.preview_url or '') | tojson }}, {{ (format.agent_url or '') | tojson }}, {{ format.id | tojson }});" style="cursor: help; color: #007bff; font-size: 0.9rem; margin-left: 0.3rem; float: right;">‚ìò</span>
                <br>
                <small style="color: #666;">
                    {{ format.type }}
                    {% if format.dimensions %} - {{ format.dimensions }}{% endif %}
                    {% if format.duration %} - {{ format.duration }}{% endif %}
                </small>
            </label>
            {% endfor %}
        </div>

        <!-- Format selection summary -->
        <div id="format-summary" style="display: {% if product and product.formats %}block{% else %}none{% endif %}; padding: 1rem; background: #d4edda; border: 1px solid #28a745; border-radius: 4px; margin-top: 1rem;">
            <strong style="color: #155724;">‚úì Selected:</strong>
            <span id="format-count" style="font-weight: 600;">{% if product and product.formats %}{{ product.formats|length }}{% else %}0{% endif %}</span> format(s)
        </div>

        <!-- Section 4: Pricing Options (AdCP PR #88) -->
        <h3 style="margin-top: 2rem; border-bottom: 2px solid #007bff; padding-bottom: 0.5rem;">Pricing Options</h3>

        <div style="margin-top: 1.5rem; padding: 1rem; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px;">
            <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">Add one or more pricing models for this product. Buyers can choose which model to use.</p>

            <div id="pricing-options-container">
                <!-- Pricing options will be added here by JavaScript -->
            </div>

            <button type="button" class="btn btn-secondary" onclick="addPricingOption()" style="margin-top: 0.5rem;">
                + Add Pricing Option
            </button>
        </div>

        <!-- Section 5: GAM Line Item Configuration -->
        <h3 style="margin-top: 2rem; border-bottom: 2px solid #007bff; padding-bottom: 0.5rem;">GAM Line Item Configuration</h3>

        <div style="padding: 1rem; background: #e7f3ff; border-left: 4px solid #007bff; border-radius: 4px;">
            <strong>‚ÑπÔ∏è Automatic Configuration</strong>
            <p style="margin: 0.5rem 0 0 0; color: #666; font-size: 0.9rem;">
                Line item type and priority are automatically determined based on your selected pricing model:
            </p>
            <ul style="margin: 0.5rem 0 0 1.5rem; color: #666; font-size: 0.9rem;">
                <li><strong>CPM Fixed</strong> ‚Üí Standard line item (priority 8, guaranteed delivery)</li>
                <li><strong>Flat Rate</strong> ‚Üí Sponsorship line item (priority 4, guaranteed delivery)</li>
                <li><strong>CPM/VCPM/CPC Auction</strong> ‚Üí Price Priority line item (priority 12, non-guaranteed)</li>
            </ul>
        </div>

        <!-- ============================================================
             CUSTOM TARGETING (Key-Value Pairs) - WHO SEES THE ADS

             This section configures audience targeting using custom key-value pairs
             from GAM (e.g., "sport=basketball", "genre=action", "age=18-34").

             This is SEPARATE from inventory targeting (which ad units/placements).

             Example: If you want ads to only show to sports fans watching basketball,
             you'd use custom targeting here: sport=basketball
             ============================================================ -->
        <h3 style="margin-top: 2rem;">üéØ Custom Targeting (Optional)</h3>
        <div class="alert" style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 1rem; margin-bottom: 1rem;">
            <strong>üí° Who Sees This:</strong> Configure custom targeting (key-value pairs) to define which audience segments will see ads for this product.
            <br><small style="color: #666;">Example: sport=basketball, genre=action, age=18-34</small>
        </div>

        {# Simple targeting selector - matches existing UI patterns #}
        {% include 'components/targeting_selector_simple.html' %}
        <input type="hidden" id="targeting-data" name="targeting_template" value='{{ product.targeting_template | tojson if product and product.targeting_template else "{}" }}'>

        <!-- Submit Buttons -->
        <div style="margin-top: 2rem; display: flex; gap: 1rem;">
            <button type="submit" class="btn btn-primary">{{ 'Update Product' if product else 'Create Product' }}</button>
            <a href="{{ url_for('products.list_products', tenant_id=tenant_id) }}" class="btn btn-secondary">Cancel</a>
        </div>
    </form>
</div>


<style>
.format-card input[type="checkbox"]:checked + strong {
    color: #007bff;
}

.format-card:has(input[type="checkbox"]:checked) {
    border-color: #007bff;
    background-color: #e7f3ff;
}

.format-card:hover {
    border-color: #007bff;
    background-color: #f8f9fa;
}

/* ============================================================================
   HIERARCHICAL TREE VIEW STYLES
   Modern tree picker with clear visual hierarchy and consistent indentation
   ============================================================================ */

/* Tree container - provides consistent spacing */
#inventory-list {
    font-size: 14px;
    line-height: 1.5;
}

/* Tree node - base structure */
.tree-node {
    position: relative;
}

/* Tree node depth indicators - consistent indentation via CSS classes
   NOTE: Use direct child selector to prevent padding cascade */
.tree-node[data-depth="0"] > .tree-node-header { padding-left: 12px; }
.tree-node[data-depth="1"] > .tree-node-header { padding-left: 36px; }
.tree-node[data-depth="2"] > .tree-node-header { padding-left: 60px; }
.tree-node[data-depth="3"] > .tree-node-header { padding-left: 84px; }
.tree-node[data-depth="4"] > .tree-node-header { padding-left: 108px; }
.tree-node[data-depth="5"] > .tree-node-header { padding-left: 132px; }
.tree-node[data-depth="6"] > .tree-node-header { padding-left: 156px; }

/* Tree node header - interactive area
   NOTE: padding-left is set per-depth via data-depth selectors above */
.tree-node-header {
    display: flex;
    align-items: center;
    padding-top: 8px;
    padding-right: 12px;
    padding-bottom: 8px;
    /* padding-left set by data-depth selector */
    margin: 0;
    border-bottom: 1px solid #f0f0f0;
    cursor: pointer;
    user-select: none;
    transition: background-color 0.15s ease, border-color 0.15s ease;
    min-height: 40px;
}

.tree-node-header:hover {
    background-color: #f8f9fa;
    border-bottom-color: #e0e0e0;
}

/* Expand/collapse toggle icon */
.tree-toggle {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 20px;
    height: 20px;
    margin-right: 8px;
    cursor: pointer;
    user-select: none;
    transition: all 0.2s ease;
    border-radius: 3px;
    flex-shrink: 0;
}

.tree-toggle:hover {
    background-color: #e3f2fd;
    color: #1976d2;
}

.tree-toggle .toggle-icon {
    font-size: 10px;
    color: #666;
    transition: transform 0.2s ease;
    display: inline-block;
}

.tree-toggle:hover .toggle-icon {
    color: #1976d2;
}

/* Loading spinner for tree expansion */
.tree-toggle .loading-spinner {
    width: 12px;
    height: 12px;
    border: 2px solid #e0e0e0;
    border-top: 2px solid #1976d2;
    border-radius: 50%;
    animation: spin 0.6s linear infinite;
    display: none;
}

.tree-toggle.loading .loading-spinner {
    display: block;
}

.tree-toggle.loading .toggle-icon {
    display: none;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Spacer for nodes without children */
.tree-spacer {
    display: inline-block;
    width: 20px;
    margin-right: 8px;
    flex-shrink: 0;
}

/* Tree children container - provides visual connection */
.tree-children {
    position: relative;
    display: none;
}

.tree-children::before {
    content: '';
    position: absolute;
    left: 10px;
    top: 0;
    bottom: 0;
    width: 1px;
    background: linear-gradient(to bottom, #e0e0e0 0%, #e0e0e0 100%);
}

/* Label container for checkbox + text */
.tree-node-label {
    display: flex;
    align-items: center;
    flex: 1;
    cursor: pointer;
    margin: 0;
    padding: 0;
    min-height: 24px;
}

/* Checkbox styling */
.ad-unit-checkbox {
    margin: 0 8px 0 0;
    cursor: pointer;
    flex-shrink: 0;
    width: 16px;
    height: 16px;
}

/* Text content container */
.tree-node-content {
    display: flex;
    flex-direction: column;
    flex: 1;
    min-width: 0; /* Allow text truncation */
}

.tree-node-name {
    font-weight: 500;
    color: #333;
    transition: color 0.15s ease;
}

.tree-node-code {
    color: #999;
    margin-left: 8px;
    font-size: 12px;
}

/* Checked state styling */
.ad-unit-checkbox:checked ~ .tree-node-content .tree-node-name {
    font-weight: 600;
    color: #1976d2;
}

.tree-node-header:has(.ad-unit-checkbox:checked) {
    background-color: #e3f2fd;
}

/* Search highlighting - nodes that match search */
.tree-node.search-match > .tree-node-header {
    background-color: #fff9e6;
    border-left: 3px solid #ffc107;
}

.tree-node.search-match > .tree-node-header .tree-node-name {
    font-weight: 600;
    color: #f57c00;
}

/* Empty state styling */
.tree-empty {
    padding: 3rem 2rem;
    text-align: center;
    color: #999;
    font-size: 14px;
}

/* Loading state */
.tree-loading {
    padding: 3rem 2rem;
    text-align: center;
    color: #666;
}

/* Accessibility improvements */
.tree-toggle:focus,
.ad-unit-checkbox:focus {
    outline: 2px solid #1976d2;
    outline-offset: 2px;
}

/* Smooth expand/collapse animation */
.tree-children[style*="display: block"] {
    animation: expandTree 0.2s ease-out;
}

@keyframes expandTree {
    from {
        opacity: 0;
        transform: translateY(-4px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}
</style>

<script>
// Global inventory cache - stores full metadata for selected items
const inventoryCache = {
    adUnits: new Map(), // id -> {id, name, metadata: {sizes: [{width, height}]}}
    placements: new Map(), // id -> {id, name, metadata: {ad_unit_ids: []}}
    extractedSizes: new Set(), // All unique sizes from selected inventory
    sizeUnitCounts: new Map() // size -> count of units with that size
};

// Inventory picker functionality
let currentPickerType = null;

function openInventoryPicker(type) {
    currentPickerType = type;
    const modal = document.getElementById('inventory-picker-modal');
    const title = document.getElementById('picker-modal-title');
    const treeControls = document.getElementById('tree-controls');

    title.textContent = type === 'ad_unit' ? 'Select Ad Units' : 'Select Placements';

    // Show/hide tree controls based on type
    if (type === 'ad_unit') {
        treeControls.style.display = 'flex';
    } else {
        treeControls.style.display = 'none';
    }

    // Clear search
    const searchInput = document.getElementById('picker-search');
    if (searchInput) {
        searchInput.value = '';
    }

    // Load inventory
    loadInventory(type);

    // Show modal
    modal.style.display = 'flex';
}

function closeInventoryPicker() {
    document.getElementById('inventory-picker-modal').style.display = 'none';
    currentPickerType = null;
}

function loadInventory(type, search = '') {
    const list = document.getElementById('inventory-list');
    list.innerHTML = '<div style="padding: 2rem; text-align: center; color: #666;">Loading...</div>';

    if (type === 'ad_unit') {
        // Load hierarchical tree for ad units
        loadInventoryTree();
    } else {
        // Load flat list for placements (keep existing behavior)
        const url = `{{ url_for('inventory.get_inventory_list', tenant_id=tenant_id) }}?type=${type}${search ? '&search=' + encodeURIComponent(search) : ''}`;

        fetch(url)
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    list.innerHTML = `<div style="padding: 2rem; text-align: center; color: #dc3545;">${data.error}</div>`;
                    return;
                }

                if (data.items.length === 0) {
                    const inventoryUrl = "{{ url_for('inventory.inventory_browser', tenant_id=tenant_id) }}";
                    list.innerHTML = `<div style="padding: 2rem; text-align: center; color: #666;">No items found. <a href="${inventoryUrl}">Sync inventory</a> first.</div>`;
                    return;
                }

                // Cache all items for later use (including metadata)
                data.items.forEach(item => {
                    inventoryCache.placements.set(item.id, item);
                });

                // Get currently selected IDs
                const fieldId = 'targeted_placement_ids';
                const field = document.getElementById(fieldId);
                const fieldValue = field ? field.value : '';
                const selectedIds = new Set(fieldValue.split(',').filter(Boolean));

                list.innerHTML = data.items.map(item => {
                    // Show ad unit count for placements
                    let metadataHtml = '';
                    if (item.metadata && item.metadata.ad_unit_ids) {
                        const count = item.metadata.ad_unit_ids.length;
                        metadataHtml = `<br><small style="color: #2196f3; font-weight: 500;">${count} ad ${count === 1 ? 'unit' : 'units'}</small>`;
                    }

                    return `
                    <label class="inventory-item" style="display: flex; align-items: center; padding: 0.75rem; border-bottom: 1px solid #eee; cursor: pointer;">
                        <input type="checkbox"
                               value="${item.id}"
                               data-sizes='${item.metadata && item.metadata.sizes ? JSON.stringify(item.metadata.sizes) : '[]'}'
                               data-path='${item.path ? JSON.stringify(item.path) : '[]'}'
                               ${selectedIds.has(item.id) ? 'checked' : ''}
                               style="margin-right: 0.75rem;">
                        <div style="flex: 1;">
                            <strong>${item.name}</strong> <small style="color: #666;">(${item.id})</small>
                            ${item.path && item.path.length > 1 ? `<br><small style="color: #666;">${item.path.join(' > ')}</small>` : ''}
                            ${metadataHtml}
                        </div>
                    </label>
                `}).join('');
            })
            .catch(error => {
                list.innerHTML = `<div style="padding: 2rem; text-align: center; color: #dc3545;">Error loading inventory: ${error.message}</div>`;
            });
    }
}

// Load hierarchical tree structure for ad units with optional search
let isLoadingTree = false; // Guard against double-loading
function loadInventoryTree(searchTerm = '') {
    if (isLoadingTree) {
        return;
    }

    isLoadingTree = true;
    const list = document.getElementById('inventory-list');

    // Build URL with search parameter if provided
    const baseUrl = `{{ url_for('inventory.get_inventory_tree', tenant_id=tenant_id) }}`;
    const url = searchTerm ? `${baseUrl}?search=${encodeURIComponent(searchTerm)}` : baseUrl;

    // Show loading indicator
    list.innerHTML = `<div style="padding: 2rem; text-align: center; color: #666;">
        <div class="spinner-border spinner-border-sm" role="status" style="margin-right: 0.5rem;"></div>
        ${searchTerm ? 'Searching...' : 'Loading ad units...'}
    </div>`;

    fetch(url)
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                list.innerHTML = `<div style="padding: 2rem; text-align: center; color: #dc3545;">${data.error}</div>`;
                return;
            }

            if (!data.root_units || data.root_units.length === 0) {
                if (searchTerm) {
                    list.innerHTML = `<div style="padding: 2rem; text-align: center; color: #666;">No ad units found matching "${searchTerm}".</div>`;
                } else {
                    const inventoryUrl = "{{ url_for('inventory.inventory_browser', tenant_id=tenant_id) }}";
                    list.innerHTML = `<div style="padding: 2rem; text-align: center; color: #666;">No ad units found. <a href="${inventoryUrl}">Sync inventory</a> first.</div>`;
                }
                return;
            }

            // Get currently selected IDs
            const field = document.getElementById('targeted_ad_unit_ids');
            const fieldValue = field ? field.value : '';
            const selectedIds = new Set(fieldValue.split(',').filter(Boolean));

            // Render tree (will be auto-expanded if search is active)
            list.innerHTML = renderAdUnitTree(data.root_units, selectedIds, 0, data.search_active);

            // Auto-expand based on context
            // Use requestAnimationFrame + setTimeout to ensure DOM is fully rendered
            requestAnimationFrame(() => {
                setTimeout(() => {
                    if (data.search_active) {
                        // Search active: expand all to show matches
                        expandAllTreeNodes();
                    } else if (selectedIds.size > 0) {
                        // No search but items selected: expand to selected
                        expandToSelected();
                    }
                    // Otherwise keep collapsed (default)
                }, 200);
            });

            isLoadingTree = false; // Reset guard
        })
        .catch(error => {
            list.innerHTML = `<div style="padding: 2rem; text-align: center; color: #dc3545;">Error loading inventory: ${error.message}</div>`;
            isLoadingTree = false; // Reset guard on error
        });
}

// Render hierarchical ad unit tree (recursive)
function renderAdUnitTree(units, selectedIds, depth = 0, searchActive = false) {
    return units.map(unit => {
        const hasChildren = unit.children && unit.children.length > 0;
        const isChecked = selectedIds.has(unit.id);
        const matchedSearch = unit.matched_search || false;

        // Store unit in cache for later use
        if (!inventoryCache.adUnits.has(unit.id)) {
            inventoryCache.adUnits.set(unit.id, {
                id: unit.id,
                name: unit.name,
                path: unit.path,
                metadata: { sizes: [] } // Will be populated when needed
            });
        }

        // Add highlight class if this node matched the search
        const highlightClass = matchedSearch ? 'search-match' : '';

        // Build HTML using CSS classes for styling
        let html = `
            <div class="tree-node ${highlightClass}" data-unit-id="${unit.id}" data-depth="${depth}">
                <div class="tree-node-header">
                    ${hasChildren ? `
                        <span class="tree-toggle" onclick="event.stopPropagation(); toggleTreeNode('${unit.id}')">
                            <span class="toggle-icon">‚ñ∂</span>
                            <span class="loading-spinner"></span>
                        </span>
                    ` : '<span class="tree-spacer"></span>'}
                    <label class="tree-node-label" onclick="event.stopPropagation();">
                        <input type="checkbox"
                               class="ad-unit-checkbox"
                               value="${unit.id}"
                               data-name="${unit.name}"
                               data-path='${JSON.stringify(unit.path || [unit.name])}'
                               ${isChecked ? 'checked' : ''}
                               onchange="handleTreeCheckboxChange(this)">
                        <div class="tree-node-content">
                            <span class="tree-node-name">
                                ${unit.name}
                                ${unit.code && unit.code !== unit.name ? `<span class="tree-node-code">${unit.code}</span>` : ''}
                            </span>
                        </div>
                    </label>
                </div>
                ${hasChildren ? `
                    <div class="tree-children">
                        ${renderAdUnitTree(unit.children, selectedIds, depth + 1, searchActive)}
                    </div>
                ` : ''}
            </div>
        `;

        return html;
    }).join('');
}

// Toggle tree node expand/collapse with loading indicator
function toggleTreeNode(unitId) {
    const node = document.querySelector(`.tree-node[data-unit-id="${unitId}"]`);
    if (!node) return;

    const children = node.querySelector('.tree-children');
    const toggle = node.querySelector('.tree-toggle');
    const toggleIcon = node.querySelector('.toggle-icon');

    if (!children || !toggle || !toggleIcon) return;

    // Check if currently expanded (display is 'block', not 'none' or empty)
    const isExpanded = children.style.display === 'block';

    if (isExpanded) {
        // Collapse - immediate, no loading needed
        children.style.display = 'none';
        toggleIcon.textContent = '‚ñ∂';
        toggle.classList.remove('loading');
    } else {
        // Expand - show loading spinner briefly for visual feedback
        toggle.classList.add('loading');

        // Use setTimeout to show spinner and allow UI to update
        setTimeout(() => {
            children.style.display = 'block';
            toggleIcon.textContent = '‚ñº';

            // Remove loading after a short delay to ensure visibility
            setTimeout(() => {
                toggle.classList.remove('loading');
            }, 150);
        }, 50);
    }
}

// Handle tree checkbox change
function handleTreeCheckboxChange(checkbox) {
    // Just update the checked state - selection will be applied on "Apply Selection"
    // No need to do anything special here
}

// Expand all tree nodes
function expandAllTreeNodes() {
    const allChildren = document.querySelectorAll('.tree-children');
    const allToggles = document.querySelectorAll('.toggle-icon');

    allChildren.forEach(children => {
        children.style.display = 'block';
    });

    allToggles.forEach(toggle => {
        toggle.textContent = '‚ñº';
    });
}

// Collapse all tree nodes
function collapseAllTreeNodes() {
    const allChildren = document.querySelectorAll('.tree-children');
    const allToggles = document.querySelectorAll('.toggle-icon');

    allChildren.forEach(children => {
        children.style.display = 'none';
    });

    allToggles.forEach(toggle => {
        toggle.textContent = '‚ñ∂';
    });
}

// Expand tree to show selected items
function expandToSelected() {
    // First collapse all
    collapseAllTreeNodes();

    // Find all checked checkboxes
    const checkedBoxes = document.querySelectorAll('#inventory-list .ad-unit-checkbox:checked');

    if (checkedBoxes.length === 0) {
        return;
    }

    // For each checked box, expand the path from root to that node
    checkedBoxes.forEach(checkbox => {
        let node = checkbox.closest('.tree-node');

        // Collect all ancestor nodes first
        const ancestors = [];
        let current = node;

        while (current) {
            ancestors.unshift(current); // Add to front (so root is first)

            // Find parent by going up through .tree-children
            const parentChildren = current.parentElement;
            if (parentChildren && parentChildren.classList.contains('tree-children')) {
                current = parentChildren.closest('.tree-node');
            } else {
                // Reached root
                break;
            }
        }

        // Now expand from root down to the selected node
        ancestors.forEach(ancestor => {
            // Find this ancestor's children container
            const childrenContainer = ancestor.querySelector(':scope > .tree-children');
            if (childrenContainer) {
                childrenContainer.style.display = 'block';
            }

            // Update toggle icon
            const toggle = ancestor.querySelector(':scope > .tree-node-header > .tree-toggle > .toggle-icon');
            if (toggle) {
                toggle.textContent = '‚ñº';
            }
        });
    });
}

// Search and filter tree nodes
function searchTreeNodes(searchTerm) {
    const term = searchTerm.toLowerCase().trim();
    const allNodes = document.querySelectorAll('.tree-node');

    if (!term) {
        // Show all nodes and collapse all
        allNodes.forEach(node => {
            node.style.display = 'block';
        });
        collapseAllTreeNodes();
        return;
    }

    // First pass: mark matching nodes
    allNodes.forEach(node => {
        const header = node.querySelector('.tree-node-header');
        const text = header ? header.textContent.toLowerCase() : '';
        const matches = text.includes(term);

        node.dataset.matches = matches ? 'true' : 'false';
        node.dataset.hasMatchingChild = 'false';
    });

    // Second pass: mark parents with matching children
    allNodes.forEach(node => {
        if (node.dataset.matches === 'true') {
            // Mark all parents as having matching children
            let parent = node.parentElement;
            while (parent && parent.classList.contains('tree-children')) {
                const parentNode = parent.closest('.tree-node');
                if (parentNode) {
                    parentNode.dataset.hasMatchingChild = 'true';
                    parent = parentNode.parentElement;
                } else {
                    break;
                }
            }
        }
    });

    // Third pass: show/hide based on matches
    allNodes.forEach(node => {
        const matches = node.dataset.matches === 'true';
        const hasMatchingChild = node.dataset.hasMatchingChild === 'true';

        if (matches || hasMatchingChild) {
            node.style.display = 'block';
            // Expand to show matching children
            if (hasMatchingChild) {
                const children = node.querySelector('.tree-children');
                const toggle = node.querySelector('.toggle-icon');
                if (children && toggle) {
                    children.style.display = 'block';
                    toggle.textContent = '‚ñº';
                }
            }
        } else {
            node.style.display = 'none';
        }
    });
}

function applyInventorySelection() {
    const checkboxes = document.querySelectorAll('#inventory-list input[type="checkbox"]:checked');
    const selectedIds = Array.from(checkboxes).map(cb => cb.value);
    const selectedNames = Array.from(checkboxes).map(cb => {
        // For tree nodes, get name from data attribute or label text
        const dataName = cb.getAttribute('data-name');
        if (dataName) {
            return dataName;
        }
        // Fallback: get from label (for flat list items)
        const label = cb.closest('label');
        const strong = label ? label.querySelector('strong') : null;
        return strong ? strong.textContent : cb.value;
    });

    if (currentPickerType === 'ad_unit') {
        document.getElementById('targeted_ad_unit_ids').value = selectedIds.join(',');
        updateSelectedDisplay('selected-ad-units', selectedNames, selectedIds);
    } else {
        document.getElementById('targeted_placement_ids').value = selectedIds.join(',');
        updateSelectedDisplay('selected-placements', selectedNames, selectedIds);
    }

    // Extract sizes from selected inventory and update UI (if function exists)
    if (typeof extractSizesFromInventory === 'function') {
        extractSizesFromInventory();
    }

    closeInventoryPicker();
}

function updateSelectedDisplay(containerId, names, ids) {
    const container = document.getElementById(containerId);
    const isAdUnit = containerId === 'selected-ad-units';

    if (names.length === 0) {
        container.innerHTML = '<span style="color: #999;">No items selected</span>';
    } else {
        container.innerHTML = names.map((name, idx) => {
            const id = ids[idx];
            let sizesText = '';

            // Show sizes inline for ad units
            if (isAdUnit) {
                const item = inventoryCache.adUnits.get(id);
                if (item && item.metadata && item.metadata.sizes && item.metadata.sizes.length > 0) {
                    const sizeStrings = item.metadata.sizes
                        .map(s => `${s.width}√ó${s.height}`)
                        .join(', ');
                    sizesText = ` <small style="color: #28a745; font-weight: 500;">(${sizeStrings})</small>`;
                }
            } else {
                // Show ad unit count for placements
                const item = inventoryCache.placements.get(id);
                if (item && item.metadata && item.metadata.ad_unit_ids) {
                    const count = item.metadata.ad_unit_ids.length;
                    sizesText = ` <small style="color: #666;">(${count} ad ${count === 1 ? 'unit' : 'units'})</small>`;
                }
            }

            return `
                <span class="selected-item" style="display: inline-block; background: #e7f3ff; color: #000; padding: 0.25rem 0.5rem; margin: 0.25rem; border-radius: 4px;">
                    ${name} <small style="color: #666;">(${id})</small>${sizesText}
                    <button type="button" onclick="removeSelectedItem('${containerId}', '${id}')" style="border: none; background: none; color: #666; cursor: pointer; margin-left: 0.25rem;">√ó</button>
                </span>
            `;
        }).join('');
    }
}

async function autoSuggestFormats(selectedCheckboxes) {
    // Collect all ad unit constraints (type + max dimensions)
    const adUnitConstraints = []; // [{type: 'display', maxWidth: 970, maxHeight: 250}, ...]
    const includeChildren = document.querySelector('input[name="include_descendants"]')?.checked;

    // First, collect constraints from directly selected ad units
    const selectedPaths = [];
    selectedCheckboxes.forEach(cb => {
        const sizesData = cb.getAttribute('data-sizes');
        const pathData = cb.getAttribute('data-path');

        // Extract path for child lookup
        let path = [];
        if (pathData) {
            try {
                path = JSON.parse(pathData);
            } catch (e) {
                console.warn('Failed to parse path data:', e);
                const label = cb.closest('label');
                const name = label.querySelector('strong').textContent.trim();
                path = [name];
            }
        }
        if (path.length > 0) {
            selectedPaths.push(path);
        }

        // Collect size constraints from this ad unit
        if (sizesData) {
            try {
                const sizes = JSON.parse(sizesData);
                sizes.forEach(size => {
                    // For now, assume all ad units are 'display' type
                    // In future, could get type from ad unit metadata
                    adUnitConstraints.push({
                        type: 'display',
                        maxWidth: size.width,
                        maxHeight: size.height
                    });
                });
            } catch (e) {
                console.warn('Failed to parse size data:', e);
            }
        }
    });

    // If "include children" is checked, fetch all ad units and find children
    if (includeChildren && selectedPaths.length > 0) {
        try {
            const url = `{{ url_for('inventory.get_inventory_list', tenant_id=tenant_id) }}?type=ad_unit`;
            const response = await fetch(url);
            const data = await response.json();

            if (data.items) {
                data.items.forEach(item => {
                    if (item.path && item.path.length > 0) {
                        for (const selectedPath of selectedPaths) {
                            const isChild = selectedPath.every((segment, idx) => item.path[idx] === segment)
                                         && item.path.length > selectedPath.length;

                            if (isChild && item.metadata && item.metadata.sizes) {
                                item.metadata.sizes.forEach(size => {
                                    adUnitConstraints.push({
                                        type: 'display',
                                        maxWidth: size.width,
                                        maxHeight: size.height
                                    });
                                });
                                break;
                            }
                        }
                    }
                });
            }
        } catch (e) {
            console.warn('Failed to fetch child ad units:', e);
        }
    }

    // Always show formats, but only show search targets if we have constraints
    const container = document.getElementById('formats-container');
    const searchTargets = document.getElementById('format-search-targets');
    const searchTargetList = document.getElementById('search-target-list');
    const searchBox = document.getElementById('format-search-box');

    container.style.display = 'grid';
    searchBox.style.display = 'block';

    // If no constraints, show all formats without filtering
    if (adUnitConstraints.length === 0) {
        searchTargets.style.display = 'none';
        // Show all formats
        const formatCheckboxes = document.querySelectorAll('#formats-container input[type="checkbox"]');
        formatCheckboxes.forEach(checkbox => {
            const card = checkbox.closest('.format-card');
            if (card) {
                card.style.display = 'block';
            }
        });
        updateFormatSummary(formatCheckboxes.length);
        return;
    }

    searchTargets.style.display = 'block';

    // Helper: Check if format fits within any ad unit constraint
    function formatFitsConstraint(formatWidth, formatHeight, formatType) {
        return adUnitConstraints.some(constraint => {
            // Type compatibility check
            // - Exact match (display ‚Üî display, video ‚Üî video, etc.)
            // - Generative formats can serve in display ad units
            // - Universal formats can serve anywhere
            const typeMatches =
                formatType === constraint.type ||
                (formatType === 'generative' && constraint.type === 'display') ||
                formatType === 'universal';

            if (!typeMatches) return false;

            // Format must fit within ad unit dimensions
            return formatWidth <= constraint.maxWidth && formatHeight <= constraint.maxHeight;
        });
    }

    // Group constraints by type for display
    const constraintsByType = {};
    adUnitConstraints.forEach(c => {
        if (!constraintsByType[c.type]) {
            constraintsByType[c.type] = [];
        }
        constraintsByType[c.type].push(`${c.maxWidth}√ó${c.maxHeight}`);
    });

    // Display search targets grouped by type
    const searchTargetHTML = Object.entries(constraintsByType)
        .map(([type, sizes]) => {
            // Get unique sizes
            const uniqueSizes = [...new Set(sizes)];
            return `
                <span style="background: #1565c0; color: white; padding: 0.4rem 0.75rem; border-radius: 4px; font-size: 0.9rem;">
                    ${type} formats ‚â§ ${uniqueSizes.join(', ')}
                </span>
            `;
        }).join('');

    searchTargetList.innerHTML = searchTargetHTML;
    searchTargets.style.display = 'block';

    // Filter and display matching formats
    const formatCards = document.querySelectorAll('.format-card');
    container.style.display = 'grid';

    // Show format actions
    const formatActions = document.getElementById('format-actions');
    if (formatActions) {
        formatActions.style.display = 'flex';
    }
    let matchingCount = 0;
    let autoCheckedCount = 0;

    console.log(`[DEBUG] Filtering ${formatCards.length} format cards`);
    console.log(`[DEBUG] Ad unit constraints:`, constraintsByType);

    formatCards.forEach((card, index) => {
        const dimensions = card.getAttribute('data-dimensions');
        const type = card.getAttribute('data-type');
        const checkbox = card.querySelector('input[type="checkbox"]');
        const name = card.querySelector('strong').textContent;

        if (index < 5) {
            console.log(`[DEBUG] Format ${index}: "${name}" type="${type}" dimensions="${dimensions}"`);
        }

        if (dimensions) {
            // Parse format dimensions (e.g., "300x250")
            const [widthStr, heightStr] = dimensions.split('x');
            const formatWidth = parseInt(widthStr, 10);
            const formatHeight = parseInt(heightStr, 10);

            if (index < 5) {
                console.log(`[DEBUG] Format ${index}: parsed w=${formatWidth} h=${formatHeight}`);
            }

            if (formatFitsConstraint(formatWidth, formatHeight, type)) {
                // This format fits - show it
                matchingCount++;
                card.style.display = 'block';

                // Auto-check if not already checked
                if (!checkbox.checked) {
                    checkbox.checked = true;
                    autoCheckedCount++;
                    // Add visual feedback
                    card.style.borderColor = '#28a745';
                    card.style.backgroundColor = '#f0fff4';
                    setTimeout(() => {
                        card.style.borderColor = '#007bff';
                        card.style.backgroundColor = '#e7f3ff';
                    }, 2000);
                }
            } else {
                // This format doesn't fit - hide it but preserve checked state
                // User might have selected it deliberately, so don't uncheck it
                // IMPORTANT: Don't disable checkbox - disabled inputs don't submit with form!
                card.style.display = 'none';
                // checkbox.disabled = true; // REMOVED - would prevent form submission
                // DO NOT uncheck: checkbox.checked = false;
            }
        } else {
            // No dimensions - hide it but preserve checked state
            // IMPORTANT: Don't disable checkbox - disabled inputs don't submit with form!
            card.style.display = 'none';
            // checkbox.disabled = true; // REMOVED - would prevent form submission
            // DO NOT uncheck: checkbox.checked = false;
        }
    });

    // Update summary
    updateFormatSummary(matchingCount);

    if (autoCheckedCount > 0) {
        console.log(`Auto-checked ${autoCheckedCount} matching format(s) from ${matchingCount} compatible formats`);
        console.log(`Constraints: ${JSON.stringify(constraintsByType)}`);
    }
}

function updateFormatSummary(matchingCount) {
    const summary = document.getElementById('format-summary');
    const countSpan = document.getElementById('format-count');

    // Only count visible checked formats
    const checkedCount = Array.from(document.querySelectorAll('.format-card input[type="checkbox"]:checked'))
        .filter(cb => cb.closest('.format-card').style.display !== 'none')
        .length;

    countSpan.textContent = checkedCount;

    if (checkedCount > 0) {
        summary.style.display = 'block';
    } else {
        summary.style.display = 'none';
    }
}

async function removeSelectedItem(containerId, idToRemove) {
    const isAdUnit = containerId === 'selected-ad-units';
    const hiddenInput = document.getElementById(isAdUnit ? 'targeted_ad_unit_ids' : 'targeted_placement_ids');
    const currentIds = hiddenInput.value.split(',').filter(Boolean);
    const newIds = currentIds.filter(id => id !== idToRemove);
    hiddenInput.value = newIds.join(',');

    // Refresh display
    const selectedNames = Array.from(document.getElementById(containerId).querySelectorAll('.selected-item'))
        .map(span => span.textContent.trim().replace('√ó', '').trim())
        .filter((_, idx) => currentIds[idx] !== idToRemove);

    updateSelectedDisplay(containerId, selectedNames, newIds);

    // Extract sizes from remaining selected inventory (both ad units and placements)
    // This ensures format sizes update when items are removed
    if (typeof extractSizesFromInventory === 'function') {
        await extractSizesFromInventory();
    }
}

// Search handler
let searchTimeout;
document.addEventListener('DOMContentLoaded', function() {
    const searchInput = document.getElementById('picker-search');
    if (searchInput) {
        searchInput.addEventListener('input', function() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                if (currentPickerType === 'ad_unit') {
                    // For tree view, reload from server with search parameter
                    loadInventoryTree(this.value);
                } else {
                    // For flat list (placements), reload from server
                    loadInventory(currentPickerType, this.value);
                }
            }, 300);
        });
    }

    // Add event listeners to format checkboxes to update summary
    const formatsContainer = document.getElementById('formats-container');
    if (formatsContainer) {
        formatsContainer.addEventListener('change', function(e) {
            if (e.target.type === 'checkbox') {
                // Update summary when formats are manually checked/unchecked
                const visibleFormats = Array.from(document.querySelectorAll('.format-card'))
                    .filter(card => card.style.display !== 'none').length;
                updateFormatSummary(visibleFormats);
            }
        });
    }
});

// Pricing Options Management (AdCP PR #88)
// Moved here so it's available for both create and edit modes
let pricingOptionIndex = 0;

function addPricingOption(existingData = null) {
    const container = document.getElementById('pricing-options-container');
    const index = pricingOptionIndex++;

    const optionHtml = `
        <div class="pricing-option" id="pricing-option-${index}" style="border: 1px solid #dee2e6; border-radius: 4px; padding: 1rem; margin-bottom: 1rem; background: white;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <h5 style="margin: 0;">Pricing Option #${index + 1}</h5>
                <button type="button" class="btn btn-secondary" onclick="removePricingOption(${index})" style="padding: 0.25rem 0.5rem; font-size: 0.85rem;">Remove</button>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                <div class="form-group">
                    <label>Pricing Model *</label>
                    <select name="pricing_model_${index}" class="pricing-model-select" onchange="updatePricingFields${index}()" required>
                        <option value="">Select...</option>
                        <optgroup label="Guaranteed (Fixed Price)">
                            <option value="cpm_fixed" ${existingData && existingData.pricing_model === 'cpm' && existingData.is_fixed ? 'selected' : ''}>CPM - Fixed Rate (Cost per 1,000 impressions)</option>
                            <option value="flat_rate" ${existingData && existingData.pricing_model === 'flat_rate' ? 'selected' : ''}>Flat Rate - Fixed Campaign Cost (Sponsorship)</option>
                        </optgroup>
                        <optgroup label="Non-Guaranteed (Auction/Bidding)">
                            <option value="cpm_auction" ${existingData && existingData.pricing_model === 'cpm' && !existingData.is_fixed ? 'selected' : ''}>CPM - Auction (Floor price bidding)</option>
                            <option value="vcpm" ${existingData && existingData.pricing_model === 'vcpm' ? 'selected' : ''}>VCPM - Auction (Viewable impressions)</option>
                            <option value="cpc" ${existingData && existingData.pricing_model === 'cpc' ? 'selected' : ''}>CPC - Auction (Cost per click)</option>
                        </optgroup>
                    </select>
                    <small style="color: #666;">All pricing models shown are supported by Google Ad Manager.</small>
                </div>

                <div class="form-group">
                    <label>Currency *</label>
                    <select name="currency_${index}" required>
                        {% for currency in currencies %}
                        <option value="{{ currency }}" ${existingData && existingData.currency === '{{ currency }}' ? 'selected' : ''}>{{ currency }}</option>
                        {% endfor %}
                    </select>
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                <div class="form-group" id="rate-group-${index}">
                    <label>Rate *</label>
                    <input type="number" name="rate_${index}" step="0.01" min="0" placeholder="e.g., 12.50" value="${existingData && existingData.rate ? existingData.rate : ''}">
                    <small style="color: #666;">Price per unit: CPM=$12.50 per 1K imps, CPC=$2.50 per click, FLAT_RATE=$5000 total campaign</small>
                </div>

                <div class="form-group" id="floor-group-${index}" style="display: none;">
                    <label>Floor Price *</label>
                    <input type="number" name="floor_${index}" step="0.01" min="0" placeholder="Minimum bid" value="${existingData && existingData.price_guidance ? existingData.price_guidance.floor : ''}">
                    <small style="color: #666;">Minimum acceptable price</small>
                </div>

                <div class="form-group">
                    <label>Min Spend Per Package</label>
                    <input type="number" name="min_spend_${index}" step="0.01" min="0" placeholder="Optional" value="${existingData && existingData.min_spend_per_package ? existingData.min_spend_per_package : ''}">
                    <small style="color: #666;">Minimum spend required for this pricing option</small>
                </div>
            </div>
        </div>
    `;

    container.insertAdjacentHTML('beforeend', optionHtml);

    // Create dynamic update function
    window[`updatePricingFields${index}`] = function() {
        const modelSelect = document.querySelector(`select[name="pricing_model_${index}"]`);
        const rateGroup = document.getElementById(`rate-group-${index}`);
        const floorGroup = document.getElementById(`floor-group-${index}`);

        const isAuction = modelSelect.value.includes('auction');

        if (isAuction) {
            rateGroup.style.display = 'none';
            floorGroup.style.display = 'block';
            document.querySelector(`input[name="rate_${index}"]`).removeAttribute('required');
            document.querySelector(`input[name="floor_${index}"]`).setAttribute('required', '');
        } else {
            rateGroup.style.display = 'block';
            floorGroup.style.display = 'none';
            document.querySelector(`input[name="rate_${index}"]`).setAttribute('required', '');
            document.querySelector(`input[name="floor_${index}"]`).removeAttribute('required');
        }
    };

    // Initialize fields if existing data
    if (existingData) {
        window[`updatePricingFields${index}`]();
    }
}

function removePricingOption(index) {
    const element = document.getElementById(`pricing-option-${index}`);
    if (element) {
        element.remove();
    }
}

// Debug form submission
function debugFormSubmission(event) {
    const formatCheckboxes = document.querySelectorAll('input[name="formats"]:checked');
    const formatValues = Array.from(formatCheckboxes).map(cb => cb.value);
    console.log('[DEBUG] Form submission - checked formats:', formatValues);
    console.log('[DEBUG] Form submission - total checked:', formatValues.length);

    if (formatValues.length === 0) {
        console.error('[DEBUG] NO FORMATS CHECKED ON SUBMIT!');
        // Don't prevent submission, just log the issue
    }

    // Debug targeting data
    const targetingField = document.getElementById('targeting-data');
    if (targetingField) {
        console.log('[DEBUG] Form submission - targeting_template field value:', targetingField.value);
        try {
            const targetingData = JSON.parse(targetingField.value);
            console.log('[DEBUG] Form submission - parsed targeting data:', targetingData);
            if (targetingData.key_value_pairs) {
                console.log('[DEBUG] Form submission - key_value_pairs:', targetingData.key_value_pairs);
            }
        } catch (e) {
            console.error('[DEBUG] Failed to parse targeting data:', e);
        }
    } else {
        console.error('[DEBUG] targeting-data field not found!');
    }

    // Debug placement data
    console.log('[DEBUG] ===== PLACEMENT DEBUG START =====');
    const placementsField = document.getElementById('targeted_placement_ids');
    console.log('[DEBUG] Placements field element:', placementsField);
    if (placementsField) {
        const placementValue = placementsField.value;
        console.log('[DEBUG] Form submission - targeted_placement_ids field value:', placementValue);
        console.log('[DEBUG] Form submission - placement value type:', typeof placementValue);
        console.log('[DEBUG] Form submission - placement value length:', placementValue.length);
        const placementIds = placementValue.split(',').filter(Boolean);
        console.log('[DEBUG] Form submission - placement IDs array:', placementIds);
        console.log('[DEBUG] Form submission - placement count:', placementIds.length);

        if (placementIds.length === 0 && placementValue) {
            console.warn('[DEBUG] Placement field has value but split resulted in empty array!');
        }
    } else {
        console.error('[DEBUG] targeted_placement_ids field not found!');
        console.error('[DEBUG] Available form fields:', Array.from(document.getElementById('product-form').elements).map(e => e.id || e.name));
    }
    console.log('[DEBUG] ===== PLACEMENT DEBUG END =====');

    // Debug ad unit data
    console.log('[DEBUG] ===== AD UNIT DEBUG START =====');
    const adUnitsField = document.getElementById('targeted_ad_unit_ids');
    console.log('[DEBUG] Ad units field element:', adUnitsField);
    if (adUnitsField) {
        const adUnitValue = adUnitsField.value;
        console.log('[DEBUG] Form submission - targeted_ad_unit_ids field value:', adUnitValue);
        console.log('[DEBUG] Form submission - ad unit value type:', typeof adUnitValue);
        console.log('[DEBUG] Form submission - ad unit value length:', adUnitValue.length);
        const adUnitIds = adUnitValue.split(',').filter(Boolean);
        console.log('[DEBUG] Form submission - ad unit IDs array:', adUnitIds);
        console.log('[DEBUG] Form submission - ad unit count:', adUnitIds.length);

        if (adUnitIds.length === 0 && adUnitValue) {
            console.warn('[DEBUG] Ad unit field has value but split resulted in empty array!');
        }
    } else {
        console.error('[DEBUG] targeted_ad_unit_ids field not found!');
        console.error('[DEBUG] Available form fields:', Array.from(document.getElementById('product-form').elements).map(e => e.id || e.name));
    }
    console.log('[DEBUG] ===== AD UNIT DEBUG END =====');

    // Continue with form submission
    return true;
}

// Filter formats based on search input
function filterGAMFormats() {
    const searchInput = document.getElementById('format-search-input');
    const searchTerm = searchInput.value.toLowerCase();
    const formatCards = document.querySelectorAll('.format-card');
    let visibleCount = 0;

    formatCards.forEach(card => {
        const formatName = card.querySelector('strong').textContent.toLowerCase();
        const formatType = card.getAttribute('data-type').toLowerCase();
        const formatDimensions = card.getAttribute('data-dimensions') || '';

        const matches = formatName.includes(searchTerm) ||
                       formatType.includes(searchTerm) ||
                       formatDimensions.includes(searchTerm);

        if (matches) {
            card.style.display = 'block';
            visibleCount++;
        } else {
            card.style.display = 'none';
        }
    });

    // Update format count
    const checkedCount = Array.from(document.querySelectorAll('.format-card input[type="checkbox"]:checked'))
        .filter(cb => cb.closest('.format-card').style.display !== 'none')
        .length;
    document.getElementById('format-count').textContent = checkedCount;
}
</script>

<!-- Inventory Picker Modal -->
<div id="inventory-picker-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
    <div style="background: white; border-radius: 8px; width: 90%; max-width: 700px; max-height: 80vh; display: flex; flex-direction: column;">
        <!-- Header -->
        <div style="padding: 1.5rem; border-bottom: 1px solid #ddd; display: flex; justify-content: space-between; align-items: center;">
            <h3 id="picker-modal-title" style="margin: 0;">Select Items</h3>
            <div id="tree-controls" style="display: none; gap: 0.5rem;">
                <button type="button" onclick="expandToSelected()" class="btn btn-sm btn-primary" style="padding: 0.25rem 0.5rem; font-size: 0.85rem;">
                    Expand to Selected
                </button>
                <button type="button" onclick="expandAllTreeNodes()" class="btn btn-sm btn-secondary" style="padding: 0.25rem 0.5rem; font-size: 0.85rem;">
                    Expand All
                </button>
                <button type="button" onclick="collapseAllTreeNodes()" class="btn btn-sm btn-secondary" style="padding: 0.25rem 0.5rem; font-size: 0.85rem;">
                    Collapse All
                </button>
            </div>
        </div>

        <!-- Search -->
        <div style="padding: 1rem; border-bottom: 1px solid #ddd;">
            <input type="text" id="picker-search" placeholder="Search..." style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;">
        </div>

        <!-- List -->
        <div id="inventory-list" style="flex: 1; overflow-y: auto; min-height: 200px;">
            <!-- Items loaded dynamically -->
        </div>

        <!-- Footer -->
        <div style="padding: 1rem; border-top: 1px solid #ddd; display: flex; gap: 0.5rem; justify-content: flex-end;">
            <button type="button" onclick="closeInventoryPicker()" class="btn btn-secondary">Cancel</button>
            <button type="button" onclick="applyInventorySelection()" class="btn btn-primary">Apply Selection</button>
        </div>
    </div>
</div>

{% if product %}
<script>
// Pre-populate form for editing
(function() {
    const product = {{ product | tojson }};
    const config = product.implementation_config || {};
    console.log('[DEBUG] Product object:', product);
    console.log('[DEBUG] Implementation config:', config);
    console.log('[DEBUG] targeted_placement_ids type:', typeof config.targeted_placement_ids);
    console.log('[DEBUG] targeted_placement_ids value:', config.targeted_placement_ids);

    // Line item type is now automatically determined from pricing model - no need to set it

    // Set pricing values
    setTimeout(() => {
        if (product.cpm) {
            const cpmField = document.getElementById('cpm');
            if (cpmField) {
                cpmField.value = product.cpm;
                console.log('Set CPM to:', product.cpm);
            }
        }
        if (product.price_guidance && product.price_guidance.min !== undefined) {
            const floorField = document.getElementById('floor_cpm');
            if (floorField) {
                floorField.value = product.price_guidance.min;
                console.log('Set floor_cpm to:', product.price_guidance.min);
            } else {
                console.warn('floor_cpm field not found!');
            }
        }
        if (config.priority) {
            const priorityField = document.getElementById('priority');
            if (priorityField) {
                priorityField.value = config.priority;
                console.log('Set priority to:', config.priority);
            }
        }
    }, 200);

    // Set countries
    if (product.countries && product.countries.length > 0) {
        const countriesSelect = document.getElementById('countries');
        Array.from(countriesSelect.options).forEach(option => {
            if (product.countries.includes(option.value)) {
                option.selected = true;
            }
        });
    }

    // Set ad units and placements - fetch actual names from inventory
    if (config.targeted_ad_unit_ids && config.targeted_ad_unit_ids.length > 0) {
        document.getElementById('targeted_ad_unit_ids').value = config.targeted_ad_unit_ids.join(',');

        // Fetch ad unit names and metadata
        fetch(`{{ url_for('inventory.get_inventory_list', tenant_id=tenant_id) }}?type=ad_unit`)
            .then(response => response.json())
            .then(data => {
                if (data.items) {
                    // Cache ad unit data in inventoryCache for size extraction
                    data.items.forEach(item => {
                        inventoryCache.adUnits.set(item.id, item);
                    });

                    const names = config.targeted_ad_unit_ids.map(id => {
                        const item = data.items.find(i => i.id === id);
                        return item ? item.name : id;
                    });
                    updateSelectedDisplay('selected-ad-units', names, config.targeted_ad_unit_ids);
                    console.log('Populated ad units:', names);

                    // Extract sizes and show formats (same as when applying selection)
                    extractSizesFromInventory();
                }
            })
            .catch(error => {
                console.error('Failed to fetch ad unit names:', error);
                // Fallback to IDs
                updateSelectedDisplay('selected-ad-units', config.targeted_ad_unit_ids, config.targeted_ad_unit_ids);
            });
    }

    if (config.targeted_placement_ids && config.targeted_placement_ids.length > 0) {
        // Handle both string and array formats
        let placementIds = config.targeted_placement_ids;
        if (typeof placementIds === 'string') {
            console.log('[DEBUG] targeted_placement_ids is a STRING, converting to array');
            placementIds = placementIds.split(',').map(id => id.trim()).filter(Boolean);
        }
        const placementIdsValue = Array.isArray(placementIds) ? placementIds.join(',') : placementIds;
        console.log('[DEBUG] Setting targeted_placement_ids hidden field:', placementIdsValue);
        console.log('[DEBUG] config.targeted_placement_ids array:', placementIds);
        document.getElementById('targeted_placement_ids').value = placementIdsValue;

        // Fetch placement names and metadata
        fetch(`{{ url_for('inventory.get_inventory_list', tenant_id=tenant_id) }}?type=placement`)
            .then(response => response.json())
            .then(data => {
                if (data.items) {
                    // Cache placement data in inventoryCache for size extraction
                    data.items.forEach(item => {
                        inventoryCache.placements.set(item.id, item);
                    });

                    const names = placementIds.map(id => {
                        const item = data.items.find(i => i.id === id);
                        return item ? item.name : id;
                    });
                    updateSelectedDisplay('selected-placements', names, placementIds);
                    console.log('Populated placements:', names);
                    console.log('Populated placement IDs:', placementIds);

                    // Extract sizes and show formats (same as when applying selection)
                    extractSizesFromInventory();
                }
            })
            .catch(error => {
                console.error('Failed to fetch placement names:', error);
                // Fallback to IDs
                updateSelectedDisplay('selected-placements', placementIds, placementIds);
            });
    }

    // Set include descendants checkbox
    if (config.include_descendants) {
        const checkbox = document.querySelector('input[name="include_descendants"]');
        if (checkbox) checkbox.checked = true;
    }

    // Set creative formats
    if (product.formats && product.formats.length > 0) {
        console.log('[DEBUG] Product formats:', product.formats);
        product.formats.forEach((format, index) => {
            // Handle both FormatReference objects and legacy string format
            let formatId, agentUrl;
            if (typeof format === 'object') {
                formatId = format.format_id || format.id;
                agentUrl = format.agent_url;
                if (index === 0) {
                    console.log('[DEBUG] First format object:', format);
                    console.log('[DEBUG] Extracted formatId:', formatId, 'agentUrl:', agentUrl);
                }
            } else {
                formatId = format;
                agentUrl = 'https://creative.adcontextprotocol.org'; // default
            }

            // Try to match against pipe-delimited format first (current format)
            let checkbox = agentUrl ? document.querySelector(`input[name="formats"][value="${agentUrl}|${formatId}"]`) : null;

            // Fallback: try to match by data-format-id attribute
            if (!checkbox) {
                checkbox = document.querySelector(`input[name="formats"][data-format-id="${formatId}"]`);
            }

            if (checkbox) {
                checkbox.checked = true;
                console.log('Checked format:', formatId);
            } else {
                console.warn('Format checkbox not found for:', formatId, '(format object:', format, ')');
            }
        });
    }
})();

// Initialize pricing options on page load
{% if product %}
// Edit mode: Load existing pricing options
const existingOptions = {{ product.pricing_options | tojson if product.pricing_options else '[]' }};
if (existingOptions.length > 0) {
    existingOptions.forEach(option => {
        addPricingOption(option);
    });
} else {
    // No existing options, add one empty option
    addPricingOption();
}
{% else %}
// Create mode: Add one empty option
addPricingOption();
{% endif %}

// Format info modal functionality
function showFormatInfo(name, description, previewUrl, agentUrl, formatId) {
    const modal = document.getElementById('format-info-modal');
    document.getElementById('format-info-name').textContent = name;
    document.getElementById('format-info-description').textContent = description;

    // Handle preview image
    const previewContainer = document.getElementById('format-preview-container');
    const previewImg = document.getElementById('format-preview-img');
    const noPreview = document.getElementById('format-no-preview');

    if (previewUrl) {
        previewImg.src = previewUrl;
        previewImg.style.display = 'block';
        noPreview.style.display = 'none';
    } else {
        previewImg.style.display = 'none';
        noPreview.style.display = 'block';
    }

    // Handle more info link
    const moreInfoLink = document.getElementById('format-more-info-link');
    if (agentUrl && formatId) {
        // Construct URL to format details on agent (most agents follow this pattern)
        const detailsUrl = `${agentUrl}/formats/${formatId}`;
        moreInfoLink.href = detailsUrl;
        moreInfoLink.style.display = 'inline-block';
    } else {
        moreInfoLink.style.display = 'none';
    }

    modal.style.display = 'block';
}

function closeFormatInfo() {
    document.getElementById('format-info-modal').style.display = 'none';
}

// Close modal when clicking outside
window.onclick = function(event) {
    const modal = document.getElementById('format-info-modal');
    if (event.target == modal) {
        modal.style.display = 'none';
    }
}

// ============================================================================
// Creative Format Size Filtering Functions
// ============================================================================

/**
 * Extract all sizes from selected ad units and placements
 */
async function extractSizesFromInventory() {
    // Clear previous sizes
    inventoryCache.extractedSizes.clear();
    inventoryCache.sizeUnitCounts.clear();

    // Get selected ad unit and placement IDs
    const adUnitIds = (document.getElementById('targeted_ad_unit_ids').value || '').split(',').filter(Boolean);
    const placementIds = (document.getElementById('targeted_placement_ids').value || '').split(',').filter(Boolean);

    // Extract sizes from ad units directly
    adUnitIds.forEach(id => {
        const item = inventoryCache.adUnits.get(id);
        if (item && item.metadata && item.metadata.sizes) {
            item.metadata.sizes.forEach(size => {
                const sizeKey = `${size.width}x${size.height}`;
                inventoryCache.extractedSizes.add(sizeKey);
                inventoryCache.sizeUnitCounts.set(
                    sizeKey,
                    (inventoryCache.sizeUnitCounts.get(sizeKey) || 0) + 1
                );
            });
        }
    });

    // For placements, need to lookup their ad units and get sizes
    // First, check which ad units need fetching
    let needsFetch = false;
    for (const placementId of placementIds) {
        const placement = inventoryCache.placements.get(placementId);
        if (placement && placement.metadata && placement.metadata.ad_unit_ids) {
            for (const adUnitId of placement.metadata.ad_unit_ids) {
                if (!inventoryCache.adUnits.has(adUnitId)) {
                    needsFetch = true;
                    break;
                }
            }
            if (needsFetch) break;
        }
    }

    // Fetch all ad units once if needed (more efficient than per-unit fetches)
    if (needsFetch) {
        try {
            const response = await fetch(
                `{{ url_for('inventory.get_inventory_list', tenant_id=tenant_id) }}?type=ad_unit`
            );
            const data = await response.json();
            data.items.forEach(item => {
                inventoryCache.adUnits.set(item.id, item);
            });
        } catch (error) {
            console.error('Failed to fetch ad units for placement sizes:', error);
            showToast('Could not load ad unit sizes from placements', 'error');
        }
    }

    // Now extract sizes from all placement ad units
    for (const placementId of placementIds) {
        const placement = inventoryCache.placements.get(placementId);
        if (placement && placement.metadata && placement.metadata.ad_unit_ids) {
            for (const adUnitId of placement.metadata.ad_unit_ids) {
                const adUnit = inventoryCache.adUnits.get(adUnitId);

                // Extract sizes from this ad unit
                if (adUnit && adUnit.metadata && adUnit.metadata.sizes) {
                    adUnit.metadata.sizes.forEach(size => {
                        const sizeKey = `${size.width}x${size.height}`;
                        inventoryCache.extractedSizes.add(sizeKey);
                        inventoryCache.sizeUnitCounts.set(
                            sizeKey,
                            (inventoryCache.sizeUnitCounts.get(sizeKey) || 0) + 1
                        );
                    });
                }
            }
        }
    }

    // Update UI
    updateSizeChipsPanel();
    updateFormatMatchIndicators();
}

/**
 * Update the size chips panel display
 */
function updateSizeChipsPanel() {
    const panel = document.getElementById('size-filter-panel');

    if (inventoryCache.extractedSizes.size === 0) {
        panel.style.display = 'none';
        return;
    }

    panel.style.display = 'block';

    // Sort sizes by count (most common first), then alphabetically
    const sortedSizes = Array.from(inventoryCache.extractedSizes).sort((a, b) => {
        const countA = inventoryCache.sizeUnitCounts.get(a) || 0;
        const countB = inventoryCache.sizeUnitCounts.get(b) || 0;
        if (countB !== countA) return countB - countA;
        return a.localeCompare(b);
    });

    const chipsContainer = document.getElementById('size-chips-container');
    chipsContainer.innerHTML = sortedSizes.map(sizeKey => {
        const count = inventoryCache.sizeUnitCounts.get(sizeKey) || 0;
        const displaySize = sizeKey.replace('x', '√ó');

        return `
            <button type="button" class="size-chip active" data-size="${sizeKey}">
                <span class="size-label">${displaySize}</span>
                <span class="unit-count">(${count} ${count === 1 ? 'unit' : 'units'})</span>
            </button>
        `;
    }).join('');
}

/**
 * Add match indicators to format cards
 */
function updateFormatMatchIndicators() {
    const formatCards = document.querySelectorAll('.format-card');

    formatCards.forEach(card => {
        // Get dimensions from data attribute (most reliable source)
        const dataDimensions = card.getAttribute('data-dimensions') || '';

        // Also try to extract from format name/label as fallback
        const formatName = card.querySelector('.format-checkbox')?.value || '';
        const formatLabel = card.querySelector('strong')?.textContent || '';
        const allText = `${dataDimensions} ${formatLabel} ${formatName}`;

        // Extract sizes from all available sources
        const formatSizes = extractSizesFromFormatName(allText);

        // Check if any format size matches inventory sizes
        const matches = formatSizes.some(size => inventoryCache.extractedSizes.has(size));

        card.classList.toggle('matches-inventory', matches);
    });

    // Update the count after adding indicators
    updateMatchingFormatsCount();

    // Show/hide the "Select All Matching" button
    const matchingCount = document.querySelectorAll('.format-card.matches-inventory').length;
    const selectMatchingBtn = document.getElementById('select-matching-formats-btn');
    if (selectMatchingBtn) {
        selectMatchingBtn.style.display = matchingCount > 0 ? 'inline-block' : 'none';
    }
}

/**
 * Extract size strings from format name (e.g., "Display 300x250" -> ["300x250"])
 */
function extractSizesFromFormatName(formatText) {
    const sizes = [];
    // Match patterns like 300x250, 300√ó250, 300 x 250
    const matches = formatText.matchAll(/(\d+)\s*[x√ó]\s*(\d+)/gi);
    for (const match of matches) {
        sizes.push(`${match[1]}x${match[2]}`);
    }
    return sizes;
}

/**
 * Update the count of matching formats
 */
function updateMatchingFormatsCount() {
    const matchingCards = document.querySelectorAll('.format-card.matches-inventory');
    const totalCards = document.querySelectorAll('.format-card').length;

    const countEl = document.getElementById('matching-formats-count');
    if (countEl) {
        countEl.textContent = `${matchingCards.length} matching / ${totalCards} total formats`;
    }
}

/**
 * Select all visible formats
 */
function selectAllFormats() {
    const formatCards = document.querySelectorAll('.format-card');
    let selectedCount = 0;

    formatCards.forEach(card => {
        // Skip hidden cards
        if (card.style.display === 'none') return;

        const checkbox = card.querySelector('input[type="checkbox"]');
        if (checkbox && !checkbox.checked) {
            checkbox.checked = true;
            selectedCount++;
        }
    });

    // Update the summary
    updateFormatSummary();

    if (selectedCount > 0) {
        showToast(`Selected ${selectedCount} ${selectedCount === 1 ? 'format' : 'formats'}`, 'success');
    }
}

/**
 * Deselect all formats
 */
function deselectAllFormats() {
    const formatCards = document.querySelectorAll('.format-card');
    let deselectedCount = 0;

    formatCards.forEach(card => {
        const checkbox = card.querySelector('input[type="checkbox"]');
        if (checkbox && checkbox.checked) {
            checkbox.checked = false;
            deselectedCount++;
        }
    });

    // Update the summary
    updateFormatSummary();

    if (deselectedCount > 0) {
        showToast(`Deselected ${deselectedCount} ${deselectedCount === 1 ? 'format' : 'formats'}`, 'info');
    }
}

/**
 * Select all formats that match inventory sizes
 */
function selectAllMatchingFormats() {
    const matchingCards = document.querySelectorAll('.format-card.matches-inventory');
    let selectedCount = 0;

    matchingCards.forEach(card => {
        const checkbox = card.querySelector('input[type="checkbox"]');
        if (checkbox && !checkbox.checked) {
            checkbox.checked = true;
            selectedCount++;
        }
    });

    // Show feedback
    if (selectedCount > 0) {
        showToast(`Selected ${selectedCount} matching ${selectedCount === 1 ? 'format' : 'formats'}`, 'success');
    }

    // Update summary
    updateFormatSummary();
}

/**
 * Toggle show only matching formats
 */
function toggleShowOnlyMatching() {
    const toggle = document.getElementById('show-only-matching-toggle');
    const showOnlyMatching = toggle.checked;

    const formatCards = document.querySelectorAll('.format-card');

    formatCards.forEach(card => {
        if (showOnlyMatching) {
            // Hide non-matching cards
            if (!card.classList.contains('matches-inventory')) {
                card.style.display = 'none';
            } else {
                card.style.display = '';
            }
        } else {
            // Show all cards
            card.style.display = '';
        }
    });
}

/**
 * Show a toast notification
 */
function showToast(message, type = 'info') {
    // Simple toast implementation
    const toast = document.createElement('div');
    toast.style.cssText = `
        position: fixed;
        bottom: 2rem;
        right: 2rem;
        background: ${type === 'success' ? '#28a745' : '#007bff'};
        color: white;
        padding: 1rem 1.5rem;
        border-radius: 4px;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        z-index: 10000;
        animation: slideIn 0.3s ease-out;
    `;
    toast.textContent = message;
    document.body.appendChild(toast);

    setTimeout(() => {
        toast.style.animation = 'slideOut 0.3s ease-in';
        setTimeout(() => toast.remove(), 300);
    }, 3000);
}

</script>

<!-- Format Info Modal -->
<div id="format-info-modal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4);">
    <div style="background-color: #fefefe; margin: 5% auto; padding: 2rem; border: 1px solid #888; border-radius: 8px; width: 90%; max-width: 500px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
            <h2 style="margin: 0; color: #333; font-size: 1.5rem;" id="format-info-name"></h2>
            <span onclick="closeFormatInfo()" style="color: #aaa; font-size: 28px; font-weight: bold; cursor: pointer; line-height: 1;">&times;</span>
        </div>

        <!-- Preview Image -->
        <div id="format-preview-container" style="margin-bottom: 1.5rem; text-align: center; background: #f8f9fa; border-radius: 4px; padding: 1rem; min-height: 200px; display: flex; align-items: center; justify-content: center;">
            <img id="format-preview-img" src="" alt="Format preview" style="max-width: 100%; max-height: 300px; border-radius: 4px; display: none;">
            <div id="format-no-preview" style="color: #999; display: none;">
                <div style="font-size: 3rem; margin-bottom: 0.5rem;">üñºÔ∏è</div>
                <div>No preview available</div>
            </div>
        </div>

        <!-- Description -->
        <div style="margin-bottom: 1.5rem;">
            <p id="format-info-description" style="color: #666; line-height: 1.6; margin: 0;"></p>
        </div>

        <!-- Actions -->
        <div style="display: flex; gap: 0.5rem;">
            <a id="format-more-info-link" href="#" target="_blank" class="btn btn-secondary" style="flex: 1; text-align: center; text-decoration: none; display: none;">
                Learn More ‚Üí
            </a>
            <button onclick="closeFormatInfo()" class="btn btn-primary" style="flex: 1;">Close</button>
        </div>
    </div>
</div>
{% endif %}

<style>
/* Size chips styling */
.size-chip {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.5rem 0.75rem;
    background: white;
    border: 2px solid #2196f3;
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 0.9rem;
}

.size-chip:hover {
    background: #e3f2fd;
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.size-chip .size-label {
    font-weight: 600;
    color: #1976d2;
}

.size-chip .unit-count {
    color: #666;
    font-size: 0.85rem;
}

/* Format card match indicator - subtle background only */
.format-card.matches-inventory {
    background: #f0f7ff !important;
}

/* Toast notification */
.toast-notification {
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 1rem 1.5rem;
    background: white;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    z-index: 10000;
    display: flex;
    align-items: center;
    gap: 0.75rem;
    animation: slideIn 0.3s ease;
}

.toast-notification.success {
    border-left: 4px solid #4caf50;
}

.toast-notification.error {
    border-left: 4px solid #f44336;
}

.toast-notification.info {
    border-left: 4px solid #2196f3;
}

@keyframes slideIn {
    from {
        transform: translateX(400px);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

@keyframes slideOut {
    from {
        transform: translateX(0);
        opacity: 1;
    }
    to {
        transform: translateX(400px);
        opacity: 0;
    }
}

.toast-notification.hiding {
    animation: slideOut 0.3s ease forwards;
}
</style>

{% endblock %}
