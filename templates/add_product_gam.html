{% extends "base.html" %}

{% block title %}{{ 'Edit' if product else 'Create' }} Product - Google Ad Manager{% endblock %}

{% block content %}
<div class="card">
    <h2>{{ 'Edit' if product else 'Create' }} Product (Google Ad Manager)</h2>

    {% if not inventory_synced %}
    <div class="alert alert-warning" style="margin-bottom: 2rem; padding: 1rem; background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px;">
        <h4 style="margin-top: 0; color: #856404;">‚ö†Ô∏è Inventory Not Synced</h4>
        <p style="margin-bottom: 1rem;">GAM inventory has not been synced yet. You won't be able to select ad units or placements until inventory is synced.</p>
        <a href="{{ url_for('inventory.inventory_browser', tenant_id=tenant_id) }}" class="btn btn-primary">
            üìä Go to Inventory Browser to Sync
        </a>
    </div>
    {% endif %}

    <form id="product-form" method="POST">
        <!-- Section 1: Product Basics -->
        <h3 style="margin-top: 0; border-bottom: 2px solid #007bff; padding-bottom: 0.5rem;">Product Information</h3>
        <p style="color: #666; margin-bottom: 1.5rem;">Basic product details that buyers will see</p>

        <div class="form-group">
            <label for="name">Product Name *</label>
            <input type="text" id="name" name="name" required placeholder="e.g., Premium Homepage Package" value="{{ product.name if product else '' }}">
        </div>

        <div class="form-group">
            <label for="description">Description</label>
            <textarea id="description" name="description" rows="3" placeholder="Describe this product for potential buyers">{{ product.description if product else '' }}</textarea>
        </div>

        <div class="form-group">
            <label for="countries">Countries</label>
            <select id="countries" name="countries" multiple size="5">
                <option value="ALL">All Countries</option>
                <option value="United States">United States</option>
                <option value="Canada">Canada</option>
                <option value="United Kingdom">United Kingdom</option>
                <option value="Australia">Australia</option>
            </select>
            <small style="color: #666;">Hold Ctrl/Cmd to select multiple, or select "All Countries"</small>
        </div>

        <!-- Section 2: GAM Inventory Selection -->
        <h3 style="margin-top: 2rem; border-bottom: 2px solid #007bff; padding-bottom: 0.5rem;">GAM Inventory</h3>
        <p style="color: #666; margin-bottom: 1.5rem;">Select ad units and placements from your GAM inventory</p>

        <div class="form-group">
            <label for="ad-unit-search">Ad Units</label>
            <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                <input type="text" id="ad-unit-search" placeholder="Search ad units..." style="flex: 1;">
                <button type="button" onclick="openInventoryPicker('ad_unit')" class="btn btn-secondary" {% if not inventory_synced %}disabled{% endif %}>
                    Browse Ad Units
                </button>
            </div>
            <div id="selected-ad-units" style="min-height: 60px; border: 1px solid #ddd; border-radius: 4px; padding: 0.5rem; background: #f9f9f9;">
                <span style="color: #999;">No ad units selected</span>
            </div>
            <textarea id="targeted_ad_unit_ids" name="targeted_ad_unit_ids" style="display: none;"></textarea>
        </div>

        <div class="form-group">
            <label for="placement-search">Placements</label>
            <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                <input type="text" id="placement-search" placeholder="Search placements..." style="flex: 1;">
                <button type="button" onclick="openInventoryPicker('placement')" class="btn btn-secondary" {% if not inventory_synced %}disabled{% endif %}>
                    Browse Placements
                </button>
            </div>
            <div id="selected-placements" style="min-height: 60px; border: 1px solid #ddd; border-radius: 4px; padding: 0.5rem; background: #f9f9f9;">
                <span style="color: #999;">No placements selected</span>
            </div>
            <textarea id="targeted_placement_ids" name="targeted_placement_ids" style="display: none;"></textarea>
        </div>

        <div class="form-group">
            <label>
                <input type="checkbox" name="include_descendants" checked>
                Include child ad units in targeting
            </label>
        </div>

        <!-- Section 3: Creative Formats -->
        <h3 style="margin-top: 2rem; border-bottom: 2px solid #007bff; padding-bottom: 0.5rem;">Creative Formats</h3>
        <p style="color: #666; margin-bottom: 1.5rem;">Select ad units first, then choose matching creative formats</p>

        <!-- Message shown before ad units are selected -->
        <div id="formats-placeholder" style="padding: 2rem; background: #f8f9fa; border: 2px dashed #ddd; border-radius: 4px; text-align: center; color: #666;">
            <p style="margin: 0; font-size: 1.1rem;">‚Üë Select ad units above to see compatible creative formats</p>
        </div>

        <!-- Size-type combos being searched (shown after ad units selected) -->
        <div id="format-search-targets" style="display: none; padding: 1rem; background: #e7f3ff; border: 1px solid #90caf9; border-radius: 4px; margin-bottom: 1rem;">
            <strong style="color: #1565c0;">Looking for formats:</strong>
            <div id="search-target-list" style="margin-top: 0.5rem; display: flex; flex-wrap: wrap; gap: 0.5rem;"></div>
        </div>

        <!-- Formats container (hidden until ad units selected) -->
        <div id="formats-container" style="display: none; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 1rem; margin-bottom: 1rem;">
            {% for format in formats %}
            <label class="format-card" data-format-id="{{ format.format_id }}" data-dimensions="{{ format.dimensions or '' }}" data-type="{{ format.type }}" style="border: 2px solid #ddd; border-radius: 4px; padding: 1rem; cursor: pointer; transition: all 0.2s;">
                <input type="checkbox" name="formats" value="{{ format.format_id }}" style="margin-right: 0.5rem;">
                <strong>{{ format.name }}</strong><br>
                <small style="color: #666;">
                    {{ format.type }}
                    {% if format.dimensions %} - {{ format.dimensions }}{% endif %}
                    {% if format.duration %} - {{ format.duration }}{% endif %}
                </small>
            </label>
            {% endfor %}
        </div>

        <!-- Format selection summary -->
        <div id="format-summary" style="display: none; padding: 1rem; background: #d4edda; border: 1px solid #28a745; border-radius: 4px; margin-top: 1rem;">
            <strong style="color: #155724;">‚úì Selected:</strong>
            <span id="format-count" style="font-weight: 600;">0</span> format(s)
        </div>

        <!-- Section 4: Pricing Options (AdCP PR #88) -->
        <h3 style="margin-top: 2rem; border-bottom: 2px solid #007bff; padding-bottom: 0.5rem;">Pricing Options</h3>

        <div style="margin-top: 1.5rem; padding: 1rem; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px;">
            <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">Add one or more pricing models for this product. Buyers can choose which model to use.</p>

            <div id="pricing-options-container">
                <!-- Pricing options will be added here by JavaScript -->
            </div>

            <button type="button" class="btn btn-secondary" onclick="addPricingOption()" style="margin-top: 0.5rem;">
                + Add Pricing Option
            </button>
        </div>

        <!-- Section 5: GAM Line Item Configuration -->
        <h3 style="margin-top: 2rem; border-bottom: 2px solid #007bff; padding-bottom: 0.5rem;">GAM Line Item Configuration</h3>

        <div class="form-group">
            <label for="line_item_type">Line Item Type *</label>
            <select id="line_item_type" name="line_item_type" required>
                <option value="STANDARD">Standard (Fixed CPM + Priority)</option>
                <option value="SPONSORSHIP">Sponsorship (Fixed CPM + Roadblock)</option>
                <option value="PRICE_PRIORITY">Price Priority (Floor CPM)</option>
                <option value="HOUSE">House (No Price)</option>
            </select>
            <small style="color: #666; display: block; margin-top: 0.25rem;">
                Standard/Sponsorship: Fixed price + priority<br>
                Price Priority: Floor price, priority 12<br>
                House: Free, priority 16
            </small>
        </div>

        <div id="priority-section" style="margin-top: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 4px;">
            <div class="form-group" id="priority-container" style="margin: 0;">
                <!-- Priority field shown/hidden based on line item type -->
            </div>
        </div>

        <!-- Submit Buttons -->
        <div style="margin-top: 2rem; display: flex; gap: 1rem;">
            <button type="submit" class="btn btn-primary">{{ 'Update Product' if product else 'Create Product' }}</button>
            <a href="{{ url_for('products.list_products', tenant_id=tenant_id) }}" class="btn btn-secondary">Cancel</a>
        </div>
    </form>
</div>

<style>
.format-card input[type="checkbox"]:checked + strong {
    color: #007bff;
}

.format-card:has(input[type="checkbox"]:checked) {
    border-color: #007bff;
    background-color: #e7f3ff;
}

.format-card:hover {
    border-color: #007bff;
    background-color: #f8f9fa;
}
</style>

<script>
// Dynamic priority field based on line item type
document.getElementById('line_item_type').addEventListener('change', function() {
    const priorityContainer = document.getElementById('priority-container');
    const lineItemType = this.value;
    const prioritySection = document.getElementById('priority-section');

    if (lineItemType === 'STANDARD' || lineItemType === 'SPONSORSHIP') {
        // Standard/Sponsorship: Show custom priority input
        prioritySection.style.display = 'block';
        priorityContainer.innerHTML = `
            <label for="priority">Priority (1-10) *</label>
            <input type="number" id="priority" name="priority" min="1" max="10" placeholder="e.g., 5" required>
            <small style="color: #666; display: block; margin-top: 0.25rem;">Lower number = higher priority. Standard line items typically use priorities 6-10.</small>
        `;
    } else {
        // Price Priority & House: Hide priority section (handled automatically)
        prioritySection.style.display = 'none';
        priorityContainer.innerHTML = '';
    }
});

// Trigger on page load
document.getElementById('line_item_type').dispatchEvent(new Event('change'));

// Inventory picker functionality
let currentPickerType = null;

function openInventoryPicker(type) {
    currentPickerType = type;
    const modal = document.getElementById('inventory-picker-modal');
    const title = document.getElementById('picker-modal-title');
    title.textContent = type === 'ad_unit' ? 'Select Ad Units' : 'Select Placements';

    // Load inventory
    loadInventory(type);

    // Show modal
    modal.style.display = 'flex';
}

function closeInventoryPicker() {
    document.getElementById('inventory-picker-modal').style.display = 'none';
    currentPickerType = null;
}

function loadInventory(type, search = '') {
    const list = document.getElementById('inventory-list');
    list.innerHTML = '<div style="padding: 2rem; text-align: center; color: #666;">Loading...</div>';

    const url = `{{ url_for('inventory.get_inventory_list', tenant_id=tenant_id) }}?type=${type}${search ? '&search=' + encodeURIComponent(search) : ''}`;

    fetch(url)
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                list.innerHTML = `<div style="padding: 2rem; text-align: center; color: #dc3545;">${data.error}</div>`;
                return;
            }

            if (data.items.length === 0) {
                const inventoryUrl = "{{ url_for('inventory.inventory_browser', tenant_id=tenant_id) }}";
                list.innerHTML = `<div style="padding: 2rem; text-align: center; color: #666;">No items found. <a href="${inventoryUrl}">Sync inventory</a> first.</div>`;
                return;
            }

            // Get currently selected IDs
            const selectedIds = type === 'ad_unit'
                ? new Set((document.getElementById('targeted_ad_unit_ids').value || '').split(',').filter(Boolean))
                : new Set((document.getElementById('targeted_placement_ids').value || '').split(',').filter(Boolean));

            list.innerHTML = data.items.map(item => {
                // Extract sizes for ad units
                let sizesHtml = '';
                if (type === 'ad_unit' && item.metadata && item.metadata.sizes && item.metadata.sizes.length > 0) {
                    const sizeStrings = item.metadata.sizes.map(s => `${s.width}x${s.height}`).join(', ');
                    sizesHtml = `<br><small style="color: #28a745; font-weight: 500;">Sizes: ${sizeStrings}</small>`;
                }

                return `
                <label class="inventory-item" style="display: flex; align-items: center; padding: 0.75rem; border-bottom: 1px solid #eee; cursor: pointer;">
                    <input type="checkbox"
                           value="${item.id}"
                           data-sizes='${item.metadata && item.metadata.sizes ? JSON.stringify(item.metadata.sizes) : '[]'}'
                           data-path='${item.path ? JSON.stringify(item.path) : '[]'}'
                           ${selectedIds.has(item.id) ? 'checked' : ''}
                           style="margin-right: 0.75rem;">
                    <div style="flex: 1;">
                        <strong>${item.name}</strong>
                        ${item.path && item.path.length > 1 ? `<br><small style="color: #666;">${item.path.join(' > ')}</small>` : ''}
                        ${sizesHtml}
                    </div>
                </label>
            `}).join('');
        })
        .catch(error => {
            list.innerHTML = `<div style="padding: 2rem; text-align: center; color: #dc3545;">Error loading inventory: ${error.message}</div>`;
        });
}

function applyInventorySelection() {
    const checkboxes = document.querySelectorAll('#inventory-list input[type="checkbox"]:checked');
    const selectedIds = Array.from(checkboxes).map(cb => cb.value);
    const selectedNames = Array.from(checkboxes).map(cb => {
        const label = cb.closest('label');
        return label.querySelector('strong').textContent;
    });

    if (currentPickerType === 'ad_unit') {
        document.getElementById('targeted_ad_unit_ids').value = selectedIds.join(',');
        updateSelectedDisplay('selected-ad-units', selectedNames, selectedIds);

        // Auto-suggest creative formats based on ad unit sizes
        autoSuggestFormats(checkboxes);
    } else {
        document.getElementById('targeted_placement_ids').value = selectedIds.join(',');
        updateSelectedDisplay('selected-placements', selectedNames, selectedIds);
    }

    closeInventoryPicker();
}

function updateSelectedDisplay(containerId, names, ids) {
    const container = document.getElementById(containerId);
    if (names.length === 0) {
        container.innerHTML = '<span style="color: #999;">No items selected</span>';
    } else {
        container.innerHTML = names.map((name, idx) => `
            <span class="selected-item" style="display: inline-block; background: #e7f3ff; padding: 0.25rem 0.5rem; margin: 0.25rem; border-radius: 4px;">
                ${name}
                <button type="button" onclick="removeSelectedItem('${containerId}', '${ids[idx]}')" style="border: none; background: none; color: #666; cursor: pointer; margin-left: 0.25rem;">√ó</button>
            </span>
        `).join('');
    }
}

async function autoSuggestFormats(selectedCheckboxes) {
    // Collect all ad unit constraints (type + max dimensions)
    const adUnitConstraints = []; // [{type: 'display', maxWidth: 970, maxHeight: 250}, ...]
    const includeChildren = document.querySelector('input[name="include_descendants"]')?.checked;

    // First, collect constraints from directly selected ad units
    const selectedPaths = [];
    selectedCheckboxes.forEach(cb => {
        const sizesData = cb.getAttribute('data-sizes');
        const pathData = cb.getAttribute('data-path');

        // Extract path for child lookup
        let path = [];
        if (pathData) {
            try {
                path = JSON.parse(pathData);
            } catch (e) {
                console.warn('Failed to parse path data:', e);
                const label = cb.closest('label');
                const name = label.querySelector('strong').textContent.trim();
                path = [name];
            }
        }
        if (path.length > 0) {
            selectedPaths.push(path);
        }

        // Collect size constraints from this ad unit
        if (sizesData) {
            try {
                const sizes = JSON.parse(sizesData);
                sizes.forEach(size => {
                    // For now, assume all ad units are 'display' type
                    // In future, could get type from ad unit metadata
                    adUnitConstraints.push({
                        type: 'display',
                        maxWidth: size.width,
                        maxHeight: size.height
                    });
                });
            } catch (e) {
                console.warn('Failed to parse size data:', e);
            }
        }
    });

    // If "include children" is checked, fetch all ad units and find children
    if (includeChildren && selectedPaths.length > 0) {
        try {
            const url = `{{ url_for('inventory.get_inventory_list', tenant_id=tenant_id) }}?type=ad_unit`;
            const response = await fetch(url);
            const data = await response.json();

            if (data.items) {
                data.items.forEach(item => {
                    if (item.path && item.path.length > 0) {
                        for (const selectedPath of selectedPaths) {
                            const isChild = selectedPath.every((segment, idx) => item.path[idx] === segment)
                                         && item.path.length > selectedPath.length;

                            if (isChild && item.metadata && item.metadata.sizes) {
                                item.metadata.sizes.forEach(size => {
                                    adUnitConstraints.push({
                                        type: 'display',
                                        maxWidth: size.width,
                                        maxHeight: size.height
                                    });
                                });
                                break;
                            }
                        }
                    }
                });
            }
        } catch (e) {
            console.warn('Failed to fetch child ad units:', e);
        }
    }

    // Hide placeholder and show formats container
    const placeholder = document.getElementById('formats-placeholder');
    const container = document.getElementById('formats-container');
    const searchTargets = document.getElementById('format-search-targets');
    const searchTargetList = document.getElementById('search-target-list');

    if (adUnitConstraints.length === 0) {
        placeholder.style.display = 'block';
        container.style.display = 'none';
        searchTargets.style.display = 'none';
        return;
    }

    placeholder.style.display = 'none';

    // Helper: Check if format fits within any ad unit constraint
    function formatFitsConstraint(formatWidth, formatHeight, formatType) {
        return adUnitConstraints.some(constraint => {
            // Type compatibility check
            // - Exact match (display ‚Üî display, video ‚Üî video, etc.)
            // - Generative formats can serve in display ad units
            // - Universal formats can serve anywhere
            const typeMatches =
                formatType === constraint.type ||
                (formatType === 'generative' && constraint.type === 'display') ||
                formatType === 'universal';

            if (!typeMatches) return false;

            // Format must fit within ad unit dimensions
            return formatWidth <= constraint.maxWidth && formatHeight <= constraint.maxHeight;
        });
    }

    // Group constraints by type for display
    const constraintsByType = {};
    adUnitConstraints.forEach(c => {
        if (!constraintsByType[c.type]) {
            constraintsByType[c.type] = [];
        }
        constraintsByType[c.type].push(`${c.maxWidth}√ó${c.maxHeight}`);
    });

    // Display search targets grouped by type
    const searchTargetHTML = Object.entries(constraintsByType)
        .map(([type, sizes]) => {
            // Get unique sizes
            const uniqueSizes = [...new Set(sizes)];
            return `
                <span style="background: #1565c0; color: white; padding: 0.4rem 0.75rem; border-radius: 4px; font-size: 0.9rem;">
                    ${type} formats ‚â§ ${uniqueSizes.join(', ')}
                </span>
            `;
        }).join('');

    searchTargetList.innerHTML = searchTargetHTML;
    searchTargets.style.display = 'block';

    // Filter and display matching formats
    const formatCards = document.querySelectorAll('.format-card');
    container.style.display = 'grid';
    let matchingCount = 0;
    let autoCheckedCount = 0;

    console.log(`[DEBUG] Filtering ${formatCards.length} format cards`);
    console.log(`[DEBUG] Ad unit constraints:`, constraintsByType);

    formatCards.forEach((card, index) => {
        const dimensions = card.getAttribute('data-dimensions');
        const type = card.getAttribute('data-type');
        const checkbox = card.querySelector('input[type="checkbox"]');
        const name = card.querySelector('strong').textContent;

        if (index < 5) {
            console.log(`[DEBUG] Format ${index}: "${name}" type="${type}" dimensions="${dimensions}"`);
        }

        if (dimensions) {
            // Parse format dimensions (e.g., "300x250")
            const [widthStr, heightStr] = dimensions.split('x');
            const formatWidth = parseInt(widthStr, 10);
            const formatHeight = parseInt(heightStr, 10);

            if (index < 5) {
                console.log(`[DEBUG] Format ${index}: parsed w=${formatWidth} h=${formatHeight}`);
            }

            if (formatFitsConstraint(formatWidth, formatHeight, type)) {
                // This format fits - show it
                matchingCount++;
                card.style.display = 'block';
                checkbox.disabled = false;

                // Auto-check if not already checked
                if (!checkbox.checked) {
                    checkbox.checked = true;
                    autoCheckedCount++;
                    // Add visual feedback
                    card.style.borderColor = '#28a745';
                    card.style.backgroundColor = '#f0fff4';
                    setTimeout(() => {
                        card.style.borderColor = '#007bff';
                        card.style.backgroundColor = '#e7f3ff';
                    }, 2000);
                }
            } else {
                // This format doesn't fit - hide it completely
                card.style.display = 'none';
                checkbox.disabled = true;
                checkbox.checked = false;
            }
        } else {
            // No dimensions - hide it
            card.style.display = 'none';
            checkbox.disabled = true;
            checkbox.checked = false;
        }
    });

    // Update summary
    updateFormatSummary(matchingCount);

    if (autoCheckedCount > 0) {
        console.log(`Auto-checked ${autoCheckedCount} matching format(s) from ${matchingCount} compatible formats`);
        console.log(`Constraints: ${JSON.stringify(constraintsByType)}`);
    }
}

function updateFormatSummary(matchingCount) {
    const summary = document.getElementById('format-summary');
    const countSpan = document.getElementById('format-count');

    // Only count visible checked formats
    const checkedCount = Array.from(document.querySelectorAll('.format-card input[type="checkbox"]:checked'))
        .filter(cb => cb.closest('.format-card').style.display !== 'none')
        .length;

    countSpan.textContent = checkedCount;

    if (checkedCount > 0) {
        summary.style.display = 'block';
    } else {
        summary.style.display = 'none';
    }
}

async function removeSelectedItem(containerId, idToRemove) {
    const isAdUnit = containerId === 'selected-ad-units';
    const hiddenInput = document.getElementById(isAdUnit ? 'targeted_ad_unit_ids' : 'targeted_placement_ids');
    const currentIds = hiddenInput.value.split(',').filter(Boolean);
    const newIds = currentIds.filter(id => id !== idToRemove);
    hiddenInput.value = newIds.join(',');

    // Refresh display
    const selectedNames = Array.from(document.getElementById(containerId).querySelectorAll('.selected-item'))
        .map(span => span.textContent.trim().replace('√ó', '').trim())
        .filter((_, idx) => currentIds[idx] !== idToRemove);

    updateSelectedDisplay(containerId, selectedNames, newIds);

    // If removing ad units, refresh format suggestions
    if (isAdUnit) {
        // Get remaining selected ad units from the inventory list
        const remainingCheckboxes = [];
        // We need to re-fetch to get the checkboxes with size data
        if (newIds.length > 0) {
            try {
                const url = `{{ url_for('inventory.get_inventory_list', tenant_id=tenant_id) }}?type=ad_unit`;
                const response = await fetch(url);
                const data = await response.json();

                if (data.items) {
                    // Create virtual checkboxes for remaining items
                    data.items.forEach(item => {
                        if (newIds.includes(item.id)) {
                            const virtualCheckbox = {
                                getAttribute: (attr) => {
                                    if (attr === 'data-sizes') {
                                        return item.metadata && item.metadata.sizes ? JSON.stringify(item.metadata.sizes) : '[]';
                                    }
                                    if (attr === 'data-path') {
                                        return item.path ? JSON.stringify(item.path) : '[]';
                                    }
                                    return null;
                                },
                                closest: () => ({ querySelector: () => ({ textContent: { trim: () => item.name }}) })
                            };
                            remainingCheckboxes.push(virtualCheckbox);
                        }
                    });
                }
            } catch (e) {
                console.warn('Failed to refresh format suggestions:', e);
            }
        }

        await autoSuggestFormats(remainingCheckboxes);
    }
}

// Search handler
let searchTimeout;
document.addEventListener('DOMContentLoaded', function() {
    const searchInput = document.getElementById('picker-search');
    if (searchInput) {
        searchInput.addEventListener('input', function() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                if (currentPickerType) {
                    loadInventory(currentPickerType, this.value);
                }
            }, 300);
        });
    }

    // Add event listeners to format checkboxes to update summary
    const formatsContainer = document.getElementById('formats-container');
    if (formatsContainer) {
        formatsContainer.addEventListener('change', function(e) {
            if (e.target.type === 'checkbox') {
                // Update summary when formats are manually checked/unchecked
                const visibleFormats = Array.from(document.querySelectorAll('.format-card'))
                    .filter(card => card.style.display !== 'none').length;
                updateFormatSummary(visibleFormats);
            }
        });
    }
});
</script>

<!-- Inventory Picker Modal -->
<div id="inventory-picker-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
    <div style="background: white; border-radius: 8px; width: 90%; max-width: 600px; max-height: 80vh; display: flex; flex-direction: column;">
        <!-- Header -->
        <div style="padding: 1.5rem; border-bottom: 1px solid #ddd;">
            <h3 id="picker-modal-title" style="margin: 0;">Select Items</h3>
        </div>

        <!-- Search -->
        <div style="padding: 1rem; border-bottom: 1px solid #ddd;">
            <input type="text" id="picker-search" placeholder="Search..." style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;">
        </div>

        <!-- List -->
        <div id="inventory-list" style="flex: 1; overflow-y: auto; min-height: 200px;">
            <!-- Items loaded dynamically -->
        </div>

        <!-- Footer -->
        <div style="padding: 1rem; border-top: 1px solid #ddd; display: flex; gap: 0.5rem; justify-content: flex-end;">
            <button type="button" onclick="closeInventoryPicker()" class="btn btn-secondary">Cancel</button>
            <button type="button" onclick="applyInventorySelection()" class="btn btn-primary">Apply Selection</button>
        </div>
    </div>
</div>

{% if product %}
<script>
// Pre-populate form for editing
(function() {
    const product = {{ product | tojson }};
    const config = product.implementation_config || {};

    // Set line item type
    if (config.line_item_type) {
        document.getElementById('line_item_type').value = config.line_item_type;
        // Trigger change event to populate pricing fields
        document.getElementById('line_item_type').dispatchEvent(new Event('change'));
    }

    // Set pricing values after a brief delay to let the change event populate the fields
    setTimeout(() => {
        if (product.cpm) {
            const cpmField = document.getElementById('cpm');
            if (cpmField) {
                cpmField.value = product.cpm;
                console.log('Set CPM to:', product.cpm);
            }
        }
        if (product.price_guidance && product.price_guidance.min !== undefined) {
            const floorField = document.getElementById('floor_cpm');
            if (floorField) {
                floorField.value = product.price_guidance.min;
                console.log('Set floor_cpm to:', product.price_guidance.min);
            } else {
                console.warn('floor_cpm field not found!');
            }
        }
        if (config.priority) {
            const priorityField = document.getElementById('priority');
            if (priorityField) {
                priorityField.value = config.priority;
                console.log('Set priority to:', config.priority);
            }
        }
    }, 200);

    // Set countries
    if (product.countries && product.countries.length > 0) {
        const countriesSelect = document.getElementById('countries');
        Array.from(countriesSelect.options).forEach(option => {
            if (product.countries.includes(option.value)) {
                option.selected = true;
            }
        });
    }

    // Set ad units and placements - fetch actual names from inventory
    if (config.targeted_ad_unit_ids && config.targeted_ad_unit_ids.length > 0) {
        document.getElementById('targeted_ad_unit_ids').value = config.targeted_ad_unit_ids.join(',');

        // Fetch ad unit names
        fetch(`{{ url_for('inventory.get_inventory_list', tenant_id=tenant_id) }}?type=ad_unit`)
            .then(response => response.json())
            .then(data => {
                if (data.items) {
                    const names = config.targeted_ad_unit_ids.map(id => {
                        const item = data.items.find(i => i.id === id);
                        return item ? item.name : id;
                    });
                    updateSelectedDisplay('selected-ad-units', names, config.targeted_ad_unit_ids);
                    console.log('Populated ad units:', names);
                }
            })
            .catch(error => {
                console.error('Failed to fetch ad unit names:', error);
                // Fallback to IDs
                updateSelectedDisplay('selected-ad-units', config.targeted_ad_unit_ids, config.targeted_ad_unit_ids);
            });
    }

    if (config.targeted_placement_ids && config.targeted_placement_ids.length > 0) {
        document.getElementById('targeted_placement_ids').value = config.targeted_placement_ids.join(',');

        // Fetch placement names
        fetch(`{{ url_for('inventory.get_inventory_list', tenant_id=tenant_id) }}?type=placement`)
            .then(response => response.json())
            .then(data => {
                if (data.items) {
                    const names = config.targeted_placement_ids.map(id => {
                        const item = data.items.find(i => i.id === id);
                        return item ? item.name : id;
                    });
                    updateSelectedDisplay('selected-placements', names, config.targeted_placement_ids);
                    console.log('Populated placements:', names);
                }
            })
            .catch(error => {
                console.error('Failed to fetch placement names:', error);
                // Fallback to IDs
                updateSelectedDisplay('selected-placements', config.targeted_placement_ids, config.targeted_placement_ids);
            });
    }

    // Set include descendants checkbox
    if (config.include_descendants) {
        const checkbox = document.querySelector('input[name="include_descendants"]');
        if (checkbox) checkbox.checked = true;
    }

    // Set creative formats
    if (product.formats && product.formats.length > 0) {
        product.formats.forEach(format => {
            const checkbox = document.querySelector(`input[name="formats"][value="${format}"]`);
            if (checkbox) checkbox.checked = true;
        });
    }
})();

// Pricing Options Management (AdCP PR #88)
let pricingOptionIndex = 0;

function addPricingOption(existingData = null) {
    const container = document.getElementById('pricing-options-container');
    const index = pricingOptionIndex++;

    const optionHtml = `
        <div class="pricing-option" id="pricing-option-${index}" style="border: 1px solid #dee2e6; border-radius: 4px; padding: 1rem; margin-bottom: 1rem; background: white;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <h5 style="margin: 0;">Pricing Option #${index + 1}</h5>
                <button type="button" class="btn btn-secondary" onclick="removePricingOption(${index})" style="padding: 0.25rem 0.5rem; font-size: 0.85rem;">Remove</button>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                <div class="form-group">
                    <label>Pricing Model *</label>
                    <select name="pricing_model_${index}" class="pricing-model-select" onchange="updatePricingFields${index}()" required>
                        <option value="">Select...</option>
                        <option value="cpm_fixed" ${existingData && existingData.pricing_model === 'cpm' && existingData.is_fixed ? 'selected' : ''}>CPM - Fixed Rate</option>
                        <option value="cpm_auction" ${existingData && existingData.pricing_model === 'cpm' && !existingData.is_fixed ? 'selected' : ''}>CPM - Auction</option>
                    </select>
                    <small style="color: #666;">GAM only supports CPM pricing</small>
                </div>

                <div class="form-group">
                    <label>Currency *</label>
                    <select name="currency_${index}" required>
                        {% for currency in currencies %}
                        <option value="{{ currency }}" ${existingData && existingData.currency === '{{ currency }}' ? 'selected' : ''}>{{ currency }}</option>
                        {% endfor %}
                    </select>
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                <div class="form-group" id="rate-group-${index}">
                    <label>Rate *</label>
                    <input type="number" name="rate_${index}" step="0.01" min="0" placeholder="e.g., 12.50" value="${existingData && existingData.rate ? existingData.rate : ''}">
                    <small style="color: #666;">Price per unit (CPM, CPCV, etc.)</small>
                </div>

                <div class="form-group" id="floor-group-${index}" style="display: none;">
                    <label>Floor Price *</label>
                    <input type="number" name="floor_${index}" step="0.01" min="0" placeholder="Minimum bid" value="${existingData && existingData.price_guidance ? existingData.price_guidance.floor : ''}">
                    <small style="color: #666;">Minimum acceptable price</small>
                </div>

                <div class="form-group">
                    <label>Min Spend Per Package</label>
                    <input type="number" name="min_spend_${index}" step="0.01" min="0" placeholder="Optional" value="${existingData && existingData.min_spend_per_package ? existingData.min_spend_per_package : ''}">
                    <small style="color: #666;">Minimum budget requirement</small>
                </div>
            </div>

            <div id="price-guidance-${index}" style="display: none; margin-top: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 4px;">
                <strong>Price Guidance (Optional)</strong>
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem; margin-top: 0.5rem;">
                    <input type="number" name="p25_${index}" step="0.01" placeholder="P25" value="${existingData && existingData.price_guidance && existingData.price_guidance.p25 ? existingData.price_guidance.p25 : ''}">
                    <input type="number" name="p50_${index}" step="0.01" placeholder="P50 (Median)" value="${existingData && existingData.price_guidance && existingData.price_guidance.p50 ? existingData.price_guidance.p50 : ''}">
                    <input type="number" name="p75_${index}" step="0.01" placeholder="P75" value="${existingData && existingData.price_guidance && existingData.price_guidance.p75 ? existingData.price_guidance.p75 : ''}">
                    <input type="number" name="p90_${index}" step="0.01" placeholder="P90" value="${existingData && existingData.price_guidance && existingData.price_guidance.p90 ? existingData.price_guidance.p90 : ''}">
                </div>
                <small style="color: #666;">Historical price percentiles for auction guidance</small>
            </div>

            <div id="parameters-${index}" style="margin-top: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 4px; display: none;">
                <strong>Model-Specific Parameters</strong>
                <div id="params-content-${index}" style="margin-top: 0.5rem;"></div>
            </div>
        </div>
    `;

    container.insertAdjacentHTML('beforeend', optionHtml);

    // Create the update function for this specific option
    window[`updatePricingFields${index}`] = function() {
        const pricingModel = document.querySelector(`select[name="pricing_model_${index}"]`).value;
        const rateGroup = document.getElementById(`rate-group-${index}`);
        const floorGroup = document.getElementById(`floor-group-${index}`);
        const priceGuidance = document.getElementById(`price-guidance-${index}`);

        // Determine if fixed or auction from pricing model selection
        const isFixed = pricingModel !== 'cpm_auction';

        if (isFixed) {
            rateGroup.style.display = 'block';
            floorGroup.style.display = 'none';
            priceGuidance.style.display = 'none';
            document.querySelector(`input[name="rate_${index}"]`).required = true;
            const floorInput = document.querySelector(`input[name="floor_${index}"]`);
            if (floorInput) floorInput.required = false;
        } else {
            // Auction mode (only cpm_auction)
            rateGroup.style.display = 'none';
            floorGroup.style.display = 'block';
            priceGuidance.style.display = 'block';
            document.querySelector(`input[name="rate_${index}"]`).required = false;
            document.querySelector(`input[name="floor_${index}"]`).required = true;
        }

        // No model-specific parameters for CPM (GAM only supports CPM)
        const parametersDiv = document.getElementById(`parameters-${index}`);
        parametersDiv.style.display = 'none';

        // Legacy code - GAM used to show parameters for non-CPM models, but now GAM is CPM-only
        const paramsContent = document.getElementById(`params-content-${index}`);
        const baseModel = pricingModel.startsWith('cpm_') ? 'cpm' : pricingModel;

        if (baseModel === 'cpp') {
            parametersDiv.style.display = 'block';
            const demographicValue = existingData && existingData.parameters ? existingData.parameters.demographic || '' : '';
            const minPointsValue = existingData && existingData.parameters ? existingData.parameters.min_points || '' : '';
            paramsContent.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                    <div>
                        <label>Demographic</label>
                        <input type="text" name="demographic_${index}" placeholder="e.g., A18-49" value="${demographicValue}">
                    </div>
                    <div>
                        <label>Min Points (GRPs)</label>
                        <input type="number" name="min_points_${index}" step="0.1" value="${minPointsValue}">
                    </div>
                </div>
            `;
        } else if (pricingModel === 'cpv') {
            parametersDiv.style.display = 'block';
            const viewThresholdValue = existingData && existingData.parameters ? existingData.parameters.view_threshold || '' : '';
            paramsContent.innerHTML = `
                <div>
                    <label>View Threshold</label>
                    <input type="number" name="view_threshold_${index}" step="0.01" min="0" max="1" placeholder="0.5 = 50% viewed" value="${viewThresholdValue}">
                    <small style="color: #666;">Percentage of video that must be viewed (0.0 to 1.0)</small>
                </div>
            `;
        } else {
            parametersDiv.style.display = 'none';
        }
    };

    // Initialize fields
    window[`updatePricingFields${index}`]();
}

function removePricingOption(index) {
    const option = document.getElementById(`pricing-option-${index}`);
    if (option) {
        option.remove();
    }

    // If no pricing options left, add one back
    const container = document.getElementById('pricing-options-container');
    if (container.children.length === 0) {
        addPricingOption();
    }
}

// Initialize pricing options on page load
{% if product %}
// Edit mode: Load existing pricing options
const existingOptions = {{ product.pricing_options | tojson if product.pricing_options else '[]' }};
if (existingOptions.length > 0) {
    existingOptions.forEach(option => {
        addPricingOption(option);
    });
} else {
    // No existing options, add one empty option
    addPricingOption();
}
{% else %}
// Create mode: Add one empty option
addPricingOption();
{% endif %}
</script>
{% endif %}

{% endblock %}
