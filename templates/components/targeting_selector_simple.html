<!-- Simple Targeting Selector Widget

     Clean, inline key-value selector that matches the existing UI patterns.
     No complex tabs or interfaces - just simple dropdowns and selection.
-->

<style>
.targeting-selector {
    border: 1px solid #dee2e6;
    border-radius: 4px;
    padding: 1.5rem;
    background: white;
    margin: 1rem 0;
}

.targeting-selector h4 {
    margin-top: 0;
    margin-bottom: 1rem;
    color: #333;
    font-size: 1.1rem;
}

.targeting-section {
    margin-bottom: 1.5rem;
}

.targeting-section label {
    display: block;
    font-weight: 500;
    margin-bottom: 0.5rem;
    color: #555;
}

.targeting-section select {
    width: 100%;
    padding: 0.5rem;
    border: 1px solid #ced4da;
    border-radius: 4px;
    font-size: 0.95rem;
}

.targeting-section select[multiple] {
    height: 150px;
}

.selected-items {
    margin-top: 0.5rem;
    padding: 0.5rem;
    background: #f8f9fa;
    border-radius: 4px;
    min-height: 40px;
}

.selected-item {
    display: inline-block;
    background: #007bff;
    color: white;
    padding: 0.25rem 0.75rem;
    border-radius: 3px;
    margin: 0.25rem;
    font-size: 0.85rem;
}

.selected-item button {
    background: none;
    border: none;
    color: white;
    margin-left: 0.5rem;
    cursor: pointer;
    font-weight: bold;
}

.loading {
    color: #666;
    font-style: italic;
}

.error {
    color: #dc3545;
    padding: 0.5rem;
    background: #f8d7da;
    border-radius: 4px;
}
</style>

<div class="targeting-selector">
    <h4>ðŸŽ¯ Custom Targeting</h4>

    <!-- Key-Value Pairs -->
    <div class="targeting-section">
        <label for="targeting-key-select">Select Custom Targeting Key</label>
        <select id="targeting-key-select" onchange="loadKeyValues(this.value)">
            <option value="">-- Select a key --</option>
        </select>

        <div id="targeting-values-container" style="display: none; margin-top: 1rem;">
            <label for="targeting-values-select">Select Values</label>
            <select id="targeting-values-select" multiple onchange="addSelectedValues()">
                <!-- Populated dynamically -->
            </select>
            <small style="color: #666; display: block; margin-top: 0.25rem;">
                Hold Ctrl/Cmd to select multiple values
            </small>
        </div>
    </div>

    <!-- Selected Key-Value Pairs Display -->
    <div class="targeting-section">
        <label>Selected Targeting</label>
        <div id="selected-targeting-display" class="selected-items">
            <span style="color: #999;">No targeting selected</span>
        </div>
    </div>
</div>

<script>
// Simple targeting widget - matches existing UI patterns
let selectedTargeting = {};
let availableKeys = [];
let availableValues = {};

// Load custom targeting keys on page load
document.addEventListener('DOMContentLoaded', async function() {
    try {
        const tenantId = '{{ tenant_id }}';
        const response = await fetch(`/api/tenant/${tenantId}/targeting/all`);
        const data = await response.json();

        availableKeys = data.custom_targeting_keys || [];

        // Populate keys dropdown
        const keySelect = document.getElementById('targeting-key-select');
        availableKeys.forEach(key => {
            const option = document.createElement('option');
            option.value = key.id;
            option.textContent = key.display_name || key.name;
            keySelect.appendChild(option);
        });

        // Load existing targeting if present
        const existingData = document.getElementById('targeting-data').value;
        if (existingData && existingData !== '{}') {
            try {
                selectedTargeting = JSON.parse(existingData).key_value_pairs || {};
                updateDisplay();
            } catch (e) {
                console.error('Error parsing existing targeting:', e);
            }
        }
    } catch (error) {
        console.error('Error loading targeting keys:', error);
        document.getElementById('targeting-key-select').innerHTML =
            '<option value="">Error loading keys</option>';
    }
});

// Load values for selected key
async function loadKeyValues(keyId) {
    if (!keyId) {
        document.getElementById('targeting-values-container').style.display = 'none';
        return;
    }

    const container = document.getElementById('targeting-values-container');
    const valuesSelect = document.getElementById('targeting-values-select');

    container.style.display = 'block';
    valuesSelect.innerHTML = '<option disabled>Loading...</option>';

    try {
        const tenantId = '{{ tenant_id }}';
        const response = await fetch(`/api/tenant/${tenantId}/targeting/values/${keyId}`);
        const data = await response.json();

        availableValues[keyId] = data.values || [];

        // Populate values dropdown
        valuesSelect.innerHTML = '';
        data.values.forEach(value => {
            const option = document.createElement('option');
            option.value = value.id;
            option.textContent = value.display_name || value.name;
            option.dataset.keyId = keyId;
            option.dataset.keyName = value.key_name || '';
            option.dataset.valueName = value.name;
            valuesSelect.appendChild(option);
        });
    } catch (error) {
        console.error('Error loading values:', error);
        valuesSelect.innerHTML = '<option disabled>Error loading values</option>';
    }
}

// Add selected values to targeting
function addSelectedValues() {
    const valuesSelect = document.getElementById('targeting-values-select');
    const selectedOptions = Array.from(valuesSelect.selectedOptions);

    selectedOptions.forEach(option => {
        const keyId = option.dataset.keyId;
        const keyName = option.dataset.keyName;
        const valueId = option.value;
        const valueName = option.dataset.valueName;

        // Initialize key array if doesn't exist
        if (!selectedTargeting[keyName]) {
            selectedTargeting[keyName] = [];
        }

        // Add value if not already present
        if (!selectedTargeting[keyName].includes(valueName)) {
            selectedTargeting[keyName].push(valueName);
        }
    });

    updateDisplay();
    updateHiddenField();
}

// Update visual display of selected targeting
function updateDisplay() {
    const display = document.getElementById('selected-targeting-display');

    if (Object.keys(selectedTargeting).length === 0) {
        display.innerHTML = '<span style="color: #999;">No targeting selected</span>';
        return;
    }

    let html = '';
    for (const [key, values] of Object.entries(selectedTargeting)) {
        values.forEach(value => {
            html += `
                <span class="selected-item">
                    ${key}: ${value}
                    <button type="button" onclick="removeTargeting('${key}', '${value}')">&times;</button>
                </span>
            `;
        });
    }

    display.innerHTML = html;
}

// Remove a targeting key-value pair
function removeTargeting(key, value) {
    if (selectedTargeting[key]) {
        selectedTargeting[key] = selectedTargeting[key].filter(v => v !== value);
        if (selectedTargeting[key].length === 0) {
            delete selectedTargeting[key];
        }
    }
    updateDisplay();
    updateHiddenField();
}

// Update hidden field with current targeting data
function updateHiddenField() {
    const hiddenField = document.getElementById('targeting-data');
    const targetingData = {
        key_value_pairs: selectedTargeting
    };
    hiddenField.value = JSON.stringify(targetingData);
}
</script>
